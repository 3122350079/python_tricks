# 第七章　字典的使用技巧

## 7.1 字典的默认值

Python的字典的get()方法可以在查找字典的键对应的值时提供后备值。
在许多情况下这会很方便。
让我举一个简单的例子来说明这个特性。
假设我们具有以下的数据结构，它将用户ID映射到用户名称：

    name_for_userid = {
        382: 'Alice',
        950: 'Bob',
        590: 'Dilbert',
    }

现在，我们使用此数据结构编写一个greeting()函数，
它会根据用户ID为用户返回问候语。
我们的第一个实现可能是这样：

    def greeting(userid):
        return 'Hi %s!' % name_for_userid[userid]

这是一个简单的字典查询。
这个实现从技术上讲可以运行，但前提是用户ID在`name_for_userid`字典中存在。
如果我们将无效的用户ID传递给`greeting()`函数会引发异常：

    >>> greeting(382)
    'Hi Alice!'
    >>> greeting(33333333)
    KeyError: 33333333

KeyError异常并不是我们希望看到的结果。 
在找不到用户ID时，如果函数返回通用问候语会更好。

让我们实现这个想法。
我们的第一种方法可能是简单地检查键是否在字典中，
如果用户ID不存在，则返回默认的问候。

    def greeting(userid):
        if userid in name_for_userid:
            return 'Hi %s!' % name_for_userid[userid]
        else:
            return 'Hi there!'

让我们看看这个`greeting()`的实现在之前的测试用例上表现如何：

    >>> greeting(382)
    'Hi Alice!'
    >>> greeting(33333333)
    'Hi there!'

好多了。
现在，我们对未知用户我们可以有一个通用的问候，
并且用户ID有效时，我们会保留个性化的问候。

但是这仍有改进的空间。
尽管新的实现结果和我们预期的一样，
并且看起来足够小巧，整洁，
但是它仍然可以改进。
我对当前的方法有所了解：

- 效率低下，因为它查询了两次字典。
- 冗长，比如，问候字符串的一部分有重复。
- 不Pythonic——官方Python文档推荐在这种场景下采用“寻求宽恕比许可容易”（EAFP）的编码风格：
  “这种通用的Python编码风格假定键或属性存在，并在假设错时捕获异常。”
  
一个更好的、遵循EAFP原则的实现可能会使用try…except块来捕获KeyError
而不是显式地对key存在性进行检查：

    def greeting(userid):
        try:
            return 'Hi %s!' % name_for_userid[userid]
        except KeyError:
            return 'Hi there'

就我们的最开始的需求而言，这个实现是没有问题的，
现在，我们不再需要查询字典两次。
但是我们仍然可以进一步改善它，并提供更整洁的方案。
Python的字典有一个get()方法，该方法支持一个可用作后备值的“默认”参数：

    def greeting(userid):
        return 'Hi %s!' % name_for_userid.get(userid, 'there')

调用get()时，它将检查字典中是否存在给定的键。
如果存在，则返回键的值。如果不存在，则返回默认参数的值。
`greeting`函数的这种实现仍然可以按预期工作：

    >>> greeting(950)
    'Hi Bob!'
    >>> greeting(333333)
    'Hi there!'

我们最终的greeting()实现简明，整洁且仅使用Python标准库中的功能。
因此，我相信这是这种特殊场景的最佳解决方案。

## 重点
- 在测试见是否在字典中时，避免显式使用`key in dict`进行检查。
- EAFP样式的异常处理或使用内置的get()方法是首选。
- 在某些情况下，标准库中的`collections.defaultdict`也很有用。


## 7.2 排序字典的乐趣和收益

Python字典没有固有的顺序。
你可以对其进行遍历，但是不能保证迭代以任何特定顺序返回字典中的元素（尽管这种情况在Python 3.6已经发生变化）。

但是，获得字典的排序表示通常是很有用的，
排序可根据字典的键，值或其他衍生属性将键值对按任意顺序排列。
假设你有一个字典xs，其内容如下：

    >>> xs = {'a': 4, 'c': 2, 'b': 3, 'd': 1}

要获得此字典中键值对的排序列表，
你可以先使用字典的items()方法，然后再对结果序列进行排序：

    >>> sorted(xs.items())
    [('a', 4), ('b', 3), ('c', 2), ('d', 1)]

为了比较序列，键值对元组使用Python标准的字典序进行排序。

为了比较两个元组，Python首先比较索引为零处的元素。
如果它们不同，则索引为零处元素的比较结果就是两个元组比较的结果。
如果它们相等，则比较索引为1的两个元素，依此类推。

现在，因为这些元组是从字典中获取的，每个元组中索引为零的元素都是字典的键，
考虑到字典的键都是唯一的，所以元组索引为零处的元素都是唯一的。
所以，这里没有特殊情况要处理。

在某些情况下，按字典顺序排序可能已经满足了你的需求。
在其他情况下，你可能希望按值对字典进行排序。
幸运的是，有一种方法可以完全控制元素的排序方式。
你可以通过将key函数传递给sorted()函数来控制排序结果，sorted()函数可以改变字典元素的比较方式。

key函数只是在每个元素比较之前调用的普通Python函数。
key函数以字典元素作为输入，返回排序比较所需的“键”。

不幸的是，“key”一词在两种情况下都有使用，
在这里-key函数和字典键无关，它仅将每个输入元素映射为用于比较的值。

现在，也许我们应该看一个例子。
相信我，在看到一些真实的代码后key函数会更容易理解。

假设你想获得按值排序的字典。
要获得此结果，你可以使用下面的key函数，
它通过查找元组中的第二个元素来返回每个键值对的值：

    >>> sorted(xs.items(), key=lambda x: x[1])
    [('d', 1), ('c', 2), ('b', 3), ('a', 4)]

看看存储键值对的结果列表是如何根据原始字典中存储的键值对的值进行排序的。
值得花一些时间研究一下key函数的工作原理。
你可以在各种Python上下文中应用它，这是一个很有用的概念。

实际上，这一概念非常普遍，以至于Python的标准库包含了`operator`模块。
该模块实现了一些最常用的key函数作为即插即用的构建基块，
例如，`operator.itemgetter`和`operator.attrgetter`。

这里有一个示例，说明如何在第一个示例中使用`operator.itemgetter`替换使用`lambda`的索引查找：

    >>> import operator
    >>> sorted(xs.items(), key=operator.itemgetter(1))
    [('d', 1), ('c', 2), ('b', 3), ('a', 4)]

在某些情况下，使用`operator`模块可能会更清楚地传达你的意图。
另一方面，使用简单的lambda表达式可能既可读又明确。
在这种特殊情况下，我实际上更倾向于使用lambda表达式。

使用lambda作为自定义key函数的另一个好处是你可以以更精细的方式控制排序顺序。
例如，你可以根据每个值的绝对数值对字典进行排序：

    >>> sorted(xs.items(), key=lambda x: abs(x[1]))

如果你需要颠倒排序顺序让较大的值排在最前面，
可以在调用sorted()时使用reverse=True关键字参数：

    >>> sorted(xs.items(),
               key=lambda x: x[1],
               reverse=True)
    [('a', 4), ('b', 3), ('c', 2), ('d', 1)]

就像我之前说过的，花点时间去掌握key函数在Python中的运行原理是完全值得的。
他们为你提供了很多灵活性，通常可以使你免于编写代码进行数据结构转换的麻烦。

## 重点
- 创建字典和其他集合的排序的“视图”时，你可以使用key函数来控制排序结果。
- key函数是Python中的重要概念。
  最常用的key函数甚至添加到了Python标准库的`operator`模块中。
- 函数是Python中的一等公民。这是一个在该语言中随处可见的强大的功能。


##　7.3 用字典模拟switch/case语句

Python没有`switch/case`语句，
因此有时需要写很长的`if...elif...else`语句来解决这个问题。
在本章中，你会找到一个技巧，该技巧可以使用字典和一等函数模拟`switch/case`语句。
听起来令人兴奋？太好了，我们开始！

想象一下，我们的程序中有以下if语句：

    >>> if cond == 'cond_a':
    ...     handle_a()
    ... elif cond == 'cond_b':
    ...     handle_b()
    ... else:
    ...     handle_default()

当然，只有三种不同的条件，这并不太可怕。
但是，试想一下，如果我们在此语句中有十个或更多个elif分支。
事情就会有所不同。
我认为过长的if语句是一种代码异味，它让程序更难阅读和维护。

处理长`if...elif...else`语句的一种方法是使用字典查找表进行替换，
它可以模拟`switch/case`语句的行为。

这里的想法是利用Python具有一等函數这一事实。
这意味着它们可以作为参数传递给其他函数，
作为其他函数的值返回，
賦值给变量和存储在数据结构中。

例如，我们可以定义一个函数，然后将其存储在列表中并在以后进行访问：

    >>> def myfunc(a, b):
    ...     return a + b
    ...
    >>> funcs = [myfunc]
    >>> funcs[0]
    <function myfunc at 0x107012230>

调用此函数的语法符合你的直觉期望，
我们只需在列表中使用索引，然后使用“()”语法调用函数并将参数传递给它：

    >>> funcs[0](2, 3)
    5

现在，我们如何使用一等函数来减少很长的if语句的大小？
这里的核心思想是定义字典，
将输入条件的查找键映射到执行预期操作的函数上：

    >>> func_dict = {
    ... 'cond_a': handle_a,
    ... 'cond_b': handle_b
    ... }

