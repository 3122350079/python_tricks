# 第5章 Python中常见数据结构

每个Python开发人员都应该学习和练习的是什么？

数据结构。它们是构建程序的基石。
每个数据结构提供一个特定的组织数据的方式，以便可以根据使用场景有效地访问数据。

我相信，作为开发，无论他们的技术水平或经验如何，回到基础总是会有所回报。

现在，我不主张你应该仅仅专注于扩展数据结构知识——这是一种“失败模式”，停留在理论上，从不产出任何东西……

但是我发现，花一些时间整理数据结构和算法知识总能带来回报。

无论是几天时间的“冲刺”，还是一个在不同地方都投入一点时间的正在进行的项目，并没有什么区别。
无论哪种方式，这都需要花费大量时间。

好了，Python中的数据结构？我们有列表，字典，集合...嗯，堆栈？我们有栈吗？

你会发现，麻烦在于Python在标准库中附带了大量数据结构。
但是，有时命名有点“离谱”。

经常不清楚像栈这种常见的“抽象数据类型”怎么对应到Python中的一个特定实现。
Java之类的其他语言则坚持一种更加符合“计算机科学”的明确命名方案：
列表不仅仅叫list——要么是LinkedList要么是ArrayList。

这让我们可以更容易识别这些类型的预期行为和复杂度。
Python坚持更简单和更“人性化”的命名方案，我喜欢它。
在某种程度上，这让使用Python进行编程变得非常有趣。

但是缺点是，即使是经验丰富的Python开发人员，也可能不清楚内置列表底层实现到底是链表还是动态数组。
而有一天，这些知识的缺乏将使他们感到沮丧，或者在求职面试中被拒绝。

在本书的这一部分中，你将看到基本数据结构和抽象数据类型（ADT）在Python及其标准库的实现。

我的目标是阐明最常见的抽象数据类型在Python的命名方案并为每种数据类型提供一个简短的说明。
这些信息还将帮助你在Python面试编码中大放异彩。

如果你正在寻找一本好书来补充你的通用数据结构知识，我强烈推荐史蒂文·S·斯基纳（Steven S. Skiena）的《算法》设计手册

它在教导你基础数据结（包括更高级的数据结构），和向你展示如何将其实际应用到各种算法之间取得了很好地平衡。
史蒂夫的书在编写这些章节时提供了很大帮助。

## 5.1 字典，映射和哈希表 

在Python中，字典（简称为“ dict”）是一个核心数据结构。
字典可以存储任意数量的对象，每个对象都由一个唯一的键表示。

字典通常也称为映射，哈希表。它们可以对给定键对应的任何对象进行高效的查找，插入和删除操作。

在实践中，这有什么意义呢？事实证明字典类似于真实世界中的电话簿：

电话簿使你可以快速检索与给定的键（一个人的名字）相关的信息（电话号码）。
因此，不必从前到后查阅读整个电话簿来查找某个人的电话号码，你可以直接跳到一个名字，并查找相关信息。

当讨论到怎么组织信息以保证高效查找时，这种类比在某种程度上就失效了。
但是基本的性能特征仍然存在：字典使你能够快速找到与给定的键关联的信息。

总而言之，字典是计算机科学中最重要最常用的的数据结构之一。

那么，Python如何处理字典呢？

让我们浏览一下Python中的字典实现。

### 字典

由于其重要性，Python有直接内置于核心的健壮的字典实现。

Python还提供了一些关于字典的“语法糖”。
例如，大括号字典语法和字典解析可以使你方便的定义新的字典对象：

    `phonebook = {
    'bob': 7387,
    'alice': 3719,
    'jack': 7052,
    }

    squares = {x: x * x for x in range(6)}

    >>> phonebook['alice']
    3719

    >>> squares
    {0: 0, 1: 1, 2: 4, 3: 9, 4: 16, 5: 25}`


哪些对象可以用作有效键有一些限制。

Python的字典由可哈希的键索引：
可哈希对象的哈希值在以存在期间不会发生变化（请参见__hash__），
并且可以将其与其他对象进行比较（请参见__eq__）。
此外，可哈希对象相等必须具有相同的哈希值。

诸如字符串和数字之类的不可变类型是可哈希的。
如果元组本身仅包含可哈希类型，你还可以将其用作字典键。

在大多数情况下，Python的内置字典实现已经做了你想做的一切。
字典经过了高度优化，并且是语言许多部分的基础，例如类属性和堆栈框架中的变量都存储在字典中。

Python字典基于充分测试和精心调整的哈希表实现，可以提供你期望的性能：
O(1)时间复杂度实现查找，插入，更新和删除操作。

没有理由不使用Python附带的标准dict实现。
但是，存在专门的第三方字典实现，例如，基于跳表或基于B树的字典。

除了“普通”字典对象外，Python的标准库还包括一些特殊的字典实现。
这些特殊的字典全部基于内置的字典类实现（具有同样的性能），但增加了一些便利功能。

让我们来看看它们。

## collections.OrderedDict 保存key的插入顺序

Python有一个专门的dict子类，该子类保存了添加到它的键的插入顺序：collections.OrderedDict。

虽然在CPython 3.6及更高版本中标准dict实现保存了键在的插入顺序，
但这只是CPython实现的一个副作用，并未在语言规范中定义。
因此，如果键的顺序对于你的算法正常运行很重要，最好通过显式使用OrderDict类清楚地表明这一点。

顺便说一句，OrderedDict不是核心语言的内置部分，并且必须从标准的collections模块中导入。

    `>>> import collections
    >>> d = collections.OrderedDict(one=1, two=2, three=3)
    >>> d
    OrderedDict([('one', 1), ('two', 2), ('three', 3)])
    >>> d['four'] = 4
    >>> d
    OrderedDict([('one', 1), ('two', 2),
    ('three', 3), ('four', 4)])
    >>> d.keys()
    odict_keys(['one', 'two', 'three', 'four'])`

## collections.defaultdict 键确实时，返回默认值

defaultdict是字典的另一个子类，其构造函数中可以接受一个可调用对象，
如果找不到请求的key，可以用这个可调用对象产生默认值。

与使用get()方法或捕获常规字典中的KeyError异常相比，
这样可以节省一些工作量，并可以让程序员的意图更加清晰。

    `>>> from collections import defaultdict
    >>> dd = defaultdict(list)
    # Accessing a missing key creates it and
    # initializes it using the default factory,
    # i.e. list() in this example:
    >>> dd['dogs'].append('Rufus')
    >>> dd['dogs'].append('Kathrin')
    >>> dd['dogs'].append('Mr Sniffles')
    >>> dd['dogs']
    ['Rufus', 'Kathrin', 'Mr Sniffles']`

## collections.ChainMap 组合多个字典

collections.ChainMap将多个字典组合到一个字典中。
查找操作会在基础字典中一个个进行搜索，直到找到密钥。
插入，更新和删除操作仅影响添加到链中的第一个字典。

    `>>> from collections import ChainMap
    >>> dict1 = {'one': 1, 'two': 2}
    >>> dict2 = {'three': 3, 'four': 4}
    >>> chain = ChainMap(dict1, dict2)
    >>> chain
    ChainMap({'one': 1, 'two': 2}, {'three': 3, 'four': 4})
    # ChainMap searches each collection in the chain
    # from left to right until it finds the key (or fails):
    >>> chain['three']
    3
    >>> chain['one']
    1
    >>> chain['missing']
    KeyError: 'missing'`

## types.MappingProxyType 实现只读字典的封装

MappingProxyType是标准字典的封装，提供字典数据的只读视图。
这个类在Python 3.3中添加，可用于创建字典的不可变代理版本。

例如，如果你希望从类或模块中返回包含内部状态的字典，而又不想开放写权限，那么这可能会有所帮助。
使用MappingProxyType可让你在原地实现这些限制，而无需创建该字典的完整副本。

    `>>> from types import MappingProxyType
    >>> writable = {'one': 1, 'two': 2}
    >>> read_only = MappingProxyType(writable)
    # The proxy is read-only:
    >>> read_only['one']
    1
    >>> read_only['one'] = 23
    TypeError:
    "'mappingproxy' object does not support item assignment"
    # Updates to the original are reflected in the proxy:
    >>> writable['one'] = 42
    >>> read_only
    mappingproxy({'one': 42, 'two': 2})`

## 字典总结

本章列出的所有Python字典实现都是Python标准库中内置的有效实现。

如果你正在寻找关于要在你的程序中使用哪种映射的建议，我将向你推荐内置的dict数据类型。
这是一种通用且经过优化的哈希表实现，且已经直接内置到了核心语言中。

只有你有dict所提供的特性以外的其它特殊要求时，我才会建议你使用这里列出的其他数据类型里面的一种。

是的，我仍然相信所有这些实现都是有效的，但是如果大多数时候都使用Python标准的字典实现，
那么你的代码将更加清晰，并且更容易被其他开发者维护。

## 重点

    - 字典是Python中的核心数据结构。
    - 大多数时候，内置的dict类型是“足够好”的。
    - 在Python标准库中有像只读或有序字典之类的特殊实现。


## 5.2 数组类型

数组是大多数编程语言中的基本数据结构，并且在不同的算法中具有广泛的应用。

在本章中，我们将介绍Python标准库中只使用核心语言功能的数组实现。

你会看到每种方法的优缺点，因此你可以确定哪种实现适合你的场景。
但是在我们开始之前，让我们先介绍一些基础知识。

数组如何工作，它们的作用是什么？

数组由固定大小的数据记录组成，这些记录允许每个元素根据索引进行有效定位。

由于数组将信息存储在相邻的内存块中，它们被认为是连续的数据结构（而不是链接的数据结构，例如链表。）

数组数据结构的一个现实世界中的类比是一个停车场：

你可以从整体上看待停车场并将其视为一个物体，
但在内有由唯一编号索引的停车位。
停车位是车辆的容器——每个停车位可以为空或有汽车，摩托车或其他车辆停放在上面。

但并非所有停车场都一样：

一些停车场可能只限于一种车辆。 
例如，汽车停车场不会允许将自行车停在上面。
“受限”停车场对应于“类型数组”数据结构，该数据结构仅允许存储具有相同数据类型的元素。

从性能角度来看，通过索引查找其中的元素非常快。
正确的数组实现保证在这种场景下拥有常数时间复杂度O(1)。

Python标准库中包括几个类似数组的数据结构，每个结构都具有略有不同。
让我们来看看：

## list　可变的动态数组

列表是Python核心语言的一部分。
尽管这样命名，在底层Python的列表是通过动态数组实现的。
这意味着一个列表允许添加或删除元素，
并且通过分配或释放内存，该列表会自动调整包含这些元素的后备存储。

Python列表可以包含包括函数在内的任意元素——Python中一切皆对象。
因此，你可以混合不同类型的数据，并将它们全部存储在一个列表中。

这是一个强大的功能，但缺点是支持同时使用多种数据类型意味着数据封装通常不够紧密。
整个结构会占用更多的空间。

    `>>> arr = ['one', 'two', 'three']
    >>> arr[0]
    'one'

    # Lists have a nice repr:
    >>> arr
    ['one', 'two', 'three']

    # Lists are mutable:
    >>> arr[1] = 'hello'
    >>> arr
    ['one', 'hello', 'three']

    >>> del arr[1]
    >>> arr
    ['one', 'three']

    # Lists can hold arbitrary data types:
    >>> arr.append(23)
    >>> arr
    ['one', 'three', 23]`

## 元组，不可变容器

就像列表一样，元组也是Python核心语言的一部分。
与列表不同，Python的元组对象是不可变的。
这意味着元素不能动态添加或删除元素——元组中的所有元素都必须在创建时定义。

就像列表一样，元组可以容纳任意数据类型的元素。
有这种灵活性很强大，但同样，这也意味着与在类型数组相比数据封装并不紧密。

    `>>> arr = 'one', 'two', 'three'
    >>> arr[0]
    'one'

    # Tuples have a nice repr:
    >>> arr
    ('one', 'two', 'three')
    
    # Tuples are immutable:
    >>> arr[1] = 'hello'
    TypeError:
    "'tuple' object does not support item assignment"

    >>> del arr[1]
    TypeError:
    "'tuple' object doesn't support item deletion"
    # Tuples can hold arbitrary data types:
    # (Adding elements creates a copy of the tuple)

    >>> arr + (23,)
    ('one', 'two', 'three', 23)`

## array.array 基础的类型数组

Python的数组模块提供了对于像字节，32位整数，浮点数这些基本的C风格数据类型的存储方式，这种方式具有很高的空间利用率。

用array.array类创建的数组是可变的并且其行为和list类似，
但有一个重要区别——它们是类型数组，仅包含一种数据类型。

因为这个约束，具有许多元素的array.array对象比列表和元组更节省空间。
存储在其中的元素紧密封装，如果你需要存放许多相同类型的元素，这可能会很有用。

此外，数组支持许多与常规列表相同的方法，因此你可能可以将它们用作列表的“替代品”，而无需对代码进行其他更改。

    `>>> import array
    >>> arr = array.array('f', (1.0, 1.5, 2.0, 2.5))
    > >>> arr[1]
    1.5

    # Arrays have a nice repr:
    >>> arr
    array('f', [1.0, 1.5, 2.0, 2.5])

    # Arrays are mutable:
    >>> arr[1] = 23.0
    >>> arr
    array('f', [1.0, 23.0, 2.0, 2.5])

    >>> del arr[1]
    >>> arr
    array('f', [1.0, 2.0, 2.5])

    >>> arr.append(42.0)
    >>> arr
    array('f', [1.0, 2.0, 2.5, 42.0])

    # Arrays are "typed":
    >>> arr[1] = 'hello'
    TypeError: "must be real number, not str"
`
## str unicode字符的不可变数组

Python 3.x使用str对象将文本数据存储为不可变的Unicode字符序列。
实际上，这意味着str是一个不可变的字符数组。
奇怪的是，它也是一种递归数据结构——字符串中的每个字符都是长度为1的一个str。

字符串对象空间利用率很高，因为它们紧密包装并且他们专注于一种数据类型。
如果你要存储Unicode文本，你应该使用它们。
由于字符串在Python中是不可变的，因此修改字符串需要创建修改后的副本。
最接近的等价于“可变字符串”的实现是将单个字符存储在列表中。

    `>>> arr = 'abcd'
    >>> arr[1]
    'b'

    >>> arr
    'abcd'
    # Strings are immutable:

    >>> arr[1] = 'e'
    TypeError:
    "'str' object does not support item assignment"

    >>> del arr[1]
    TypeError:
    "'str' object doesn't support item deletion"

    # Strings can be unpacked into a list to
    # get a mutable representation:
    >>> list('abcd')
    ['a', 'b', 'c', 'd']
    >>> ''.join(list('abcd'))
    'abcd'

    # Strings are recursive data structures:
    >>> type('abc')
    "<class 'str'>"
    >>> type('abc'[0])
    "<class 'str'>"`

## 字节串　单个字节的不可变数组

字节对象是单个字节的不可变序列（范围为0 <= x <= 255）。
从概念上讲，它们类似于str对象，你也可以将它们视为字节的不可变数组。

像字符串一样，字节具有自己的创建语法，而且它们节省空间。
字节对象是不可变的，但与字符串不同，可以将字节串拆包为一种称为“可变字节数组”的专用数据类型。
在下一节你会接触到更多相关信息。

    `>>> arr = bytes((0, 1, 2, 3))
    >>> arr[1]
    1

    # Bytes literals have their own syntax:
    >>> arr
    b'x00x01x02x03'
    >>> arr = b'x00x01x02x03'

    # Only valid "bytes" are allowed:
    >>> bytes((0, 300))
    ValueError: "bytes must be in range(0, 256)"
    # Bytes are immutable:
    >>> arr[1] = 23
    TypeError:
    "'bytes' object does not support item assignment"

    >>> del arr[1]
    TypeError:
    "'bytes' object doesn't support item deletion"`


## 字节数组——可变的字节数组

bytearray类型是一个范围为0 <= x <= 255的可变整数序列。
它们与bytes的主要区别在于字节数组可以自由修改，
你可以覆盖元素，删除现有元素或添加新元素。
bytearray对象将相应地进行扩缩容。

字节数组可以转换回不可变字节对象，但是这涉及到全量复制数据，这是一个很慢的操作，时间复杂度是Ｏ(n).

    `>>> arr = bytearray((0, 1, 2, 3))
    >>> arr[1]
    1
    # The bytearray repr:
    >>> arr
    bytearray(b'x00x01x02x03')
    # Bytearrays are mutable:
    >>> arr[1] = 23
    >>> arr
    bytearray(b'x00x17x02x03')
    >>> arr[1]
    23
    # Bytearrays can grow and shrink in size:
    >>> del arr[1]
    >>> arr
    bytearray(b'x00x02x03')
    >>> arr.append(42)
    >>> arr
    bytearray(b'x00x02x03*')
    # Bytearrays can only hold "bytes"
    # (integers in the range 0 <= x <= 255)
    >>> arr[1] = 'hello'
    TypeError: "an integer is required"
    >>> arr[1] = 300
    ValueError: "byte must be in range(0, 256)"
    # Bytearrays can be converted back into bytes objects:
    # (This will copy the data)
    >>> bytes(arr)
    b'x00x02x03*'`

## 重点

在Python中需要实现数组时，你可以选择许多内置数据结构。
在本章中，我们已经聚焦于标准库中的核心语言功能和数据结构。

如果你愿意跳出Python标准库，那么可以使用像NumPy之类的第三方库，
它为科学计算和数据科学提供了广泛的快速数组实现。

如果限制到Python包含的数组类型数据结构，以下是我们的选择：

你需要存储任意对象，可能混合使用数据类型？
根据你想要可变还是不可变的数据结构，确定使用列表还是元组。

你有数字类型的数据（整数或浮点数）并且紧密包装和性能很重要？
试试array.array看看它是否可以满足你的所有需求。
另外，考虑一下标准库之外的库，试试NumPy或Pandas之类的包。

你有以Unicode字符表示的文本数据吗？
使用Python内置的str。
如果你需要“可变字符串”，请使用一个列表保存字符串。

你要存储一个连续的字节块？
使用不可变的字节类型，如果需要可变的数据结构，则使用字节数组。

在大多数情况下，我喜欢从一个简单的列表开始。
稍后，我会研究性能或存储空间是否是一个问题。
大多数情况下，使用像list这样的通用数组数据结构可以给你最快的开发速度和最大的编程便利性。

我发现与试图从一开始就压榨最后一点性能相比，这通常更重要。


## 5.3 记录，结构体和数据传输对象

与数组相比，记录数据结构提供了固定数量的字段，其中每个字段可以有一个名称，并且可以有不同的类型。

在本章中，你将了解如何仅使用内置数据类型和标准库中的类实现记录，结构体和“普通的旧数据对象”。

顺便说一句，我在这里使用记录的宽松定义。
例如，我还将讨论诸如Python的内置元组之类的类型，
从严格意义上来说，因为它们不提供命名字段，可能会或也可能不会将其视为记录。

Python提供了几种可用于实现记录的数据类型，结构体和数据传输对象。
在本章中，你将快速获得了解每个实现及其独特的特性。
在最后，你会找到总结和决策指南，这将对你有所帮助。

好了，我们开始！

## dict——简单的数据对象

Python字典存储任意数量的对象，每个对象用唯一的键标识。
字典通常也称为映射或哈希表，并允许有通过给定的键实现高效的查找，插入和删除操作。

在Python中使用字典作为记录数据类型或数据对象是可能的。
字典很容易在Python中创建，因为它们具有自己的语法糖。
字典语法简洁明了，写起来非常方便。

使用字典创建的数据对象是可变的，几乎没有防止字段名拼写错误的机制，任何时候都可以添加和删除字段。
这两个属性都可以引入令人惊讶的bug，并且始终需要在便利性和错误恢复能力之间进行权衡。

    `car1 = {
    'color': 'red',
    'mileage': 3812.4,
    'automatic': True,
    }
    car2 = {
    'color': 'blue',
    'mileage': 40231,
    'automatic': False,
    }
    # Dicts have a nice repr:
    >>> car2
    {'color': 'blue', 'automatic': False, 'mileage': 40231}
    # Get mileage:
    >>> car2['mileage']
    40231
    # Dicts are mutable:
    >>> car2['mileage'] = 12
    >>> car2['windshield'] = 'broken'
    >>> car2
    {'windshield': 'broken', 'color': 'blue',
    'automatic': False, 'mileage': 12}
    # No protection against wrong field names,
    # or missing/extra fields:
    car3 = {
    'colr': 'green',
    'automatic': False,
    'windshield': 'broken',
    }`

## 元组，对象的不可变组合

Python的元组是用于对任意对象进行组合的简单数据结构。
元组是不可变的，一旦被创建，就无法对其进行修改。

在性能方面，元组占用的内存比列表中的少一点点，并且构建起来也更快。

正如你在下面的反汇编字节码中所看到的，
构造一个元组常量时只需要一个LOAD_CONST操作码，构建具有相同内容的列表对象需要执行更多操作：

    `>>> import dis
    >>> dis.dis(compile("(23, 'a', 'b', 'c')", '', 'eval'))
    0 LOAD_CONST 4 ((23, 'a', 'b', 'c'))
    3 RETURN_VALUE
    >>> dis.dis(compile("[23, 'a', 'b', 'c']", '', 'eval'))
    0 LOAD_CONST 0 (23)
    3 LOAD_CONST 1 ('a')
    6 LOAD_CONST 2 ('b')
    9 LOAD_CONST 3 ('c')
    12 BUILD_LIST 4
    15 RETURN_VALUE`


但是，你不应过分强调这些差异。
在实践中，性能差异通常可以忽略不计，试图通过从列表切换到元组以压榨额外的性能很可能是一个错误的方法。

普通元组的潜在缺点是你存储在其中的数据只能通过整数索引的方式进行访问。
你不能为存储在元组中的各个属性命名。
这个可以影响代码的可读性。

另外，元组始终是一种临时结构：很难确保两个元组具有相同的字段数，并且相同的属性存储在它们中。

这样可以很容易因为疏忽导致bug，例如混淆字段顺序。
因此，我建议你在元组中存储的字段数越少越好。

    `# Fields: color, mileage, automatic
    >>> car1 = ('red', 3812.4, True)
    >>> car2 = ('blue', 40231.0, False)
    # Tuple instances have a nice repr:
    >>> car1
    ('red', 3812.4, True)
    >>> car2
    ('blue', 40231.0, False)
    # Get mileage:
    >>> car2[1]
    40231.0
    # Tuples are immutable:
    >>> car2[1] = 12
    TypeError:
    "'tuple' object does not support item assignment"
    # No protection against missing/extra fields
    # or a wrong order:
    >>> car3 = (3431.5, 'green', True, 'silver')`

## 写一个自己的类，做更多的工作，进行更好地控制

通过类，你可以为数据对象定义可重用的“蓝图”确保每个对象都提供相同的字段集。

使用常规的Python类作为记录数据类型是可行的，
但还是需要手动工作才能获得其他实现的便利功能。
例如，向__init__构造函数添加新字段冗长且需要时间。

另外，自定义类实例化对象的默认字符串表示形式并不是很有帮助。
要解决此问题，你可能必须添加你自己的__repr__方法，这通常也很冗长并且每次添加新字段时都必须更新。

存储在类上的字段是可变的，可以自由地添加新字段，你可能喜欢也可能不喜欢。
有可能使用@property装饰器提供更多访问控制并创建只读字段，但这又需要编写更多的胶水代码。

每当你想添加自定义类时，使用方法将业务逻辑和行为添加到记录对象中是一个不错的选择。
但是，这意味着这些对象不再是普通的数据对象。

    `class Car:
    def __init__(self, color, mileage, automatic):
    self.color = color
    self.mileage = mileage
    self.automatic = automatic
    >>> car1 = Car('red', 3812.4, True)
    >>> car2 = Car('blue', 40231.0, False)
    > # Get the mileage:
    >>> car2.mileage
    40231.0
    # Classes are mutable:
    >>> car2.mileage = 12
    >>> car2.windshield = 'broken'
    # String representation is not very useful
    # (must add a manually written __repr__ method):
    >>> car1
    <Car object at 0x1081e69e8>`

## collections.namedtuple 方便的数据对象

Python 2.6+中新增的namedtuple类提供了对内置元组数据类型的扩展。
与定义自定义类相似，使用namedtuple可以为你的数据记录定义可重用的“蓝图”，以确保使用正确的字段名称。

就像常规元组一样，命名元组是不可变的。
这意味着在namedtuple实例创建之后不能添加新字段或修改现有字段。

除此之外，命名元组是有名字的元组。
每个存储在其中的对象可以通过唯一标识符进行访问。
这使你不必记住整数索引，也不必使用一些变通方法，将整数常量定义为助记符索引。

在内部，namedtuple对象通过常规Python类实现。
在内存使用方面，它们比常规类“更好”一点，并且拥有和常规元组一样高效的内存使用率：

    `>>> from collections import namedtuple
    >>> from sys import getsizeof
    >>> p1 = namedtuple('Point', 'x y z')(1, 2, 3)
    >>> p2 = (1, 2, 3)
    >>> getsizeof(p1)
    72
    >>> getsizeof(p2)
    72`

通过强制实现一个更好的数据结构，namedtuples是保持代码整洁并提高其可读性的简单方法。

例如，我发现它来与字典等数据类型相比，固定格式的namedtuples可以帮助我更清晰地表达自己的意图。
通常，当我尝试这种重构时，我会为我面临的问题想到更好的解决方案。

在非结构化元组和字典上使用namedtuple也可以使我的同事的生活更轻松，
因为他们使传递的数据在一定程度上可以自我说明。

    `>>> from collections import namedtuple
    >>> Car = namedtuple('Car' , 'color mileage automatic')
    >>> car1 = Car('red', 3812.4, True)
    # Instances have a nice repr:
    >>> car1
    Car(color='red', mileage=3812.4, automatic=True)
    # Accessing fields:
    >>> car1.mileage
    3812.4
    # Fields are immtuable:
    >>> car1.mileage = 12
    AttributeError: "can't set attribute"
    >>> car1.windshield = 'broken'
    AttributeError:
    "'Car' object has no attribute 'windshield'"`


## typing.NamedTuple 改进的具名元组

Python 3.6中添加的这个类是collections模块中的namedtuple类的新兄弟。
它与namedtuple非常相似，主要区别是为定义新记录类型时的更新语法，此外还增加了类型提示。

请注意，如果没有像mypy这样单独的类型检查工具，类型注释不会强制执行。
但是即使没有工具的支持，他们可以为其他程序员提供有用的提示（如果类型提示已过时，则会让他们感到非常困惑。）

    `>>> from typing import NamedTuple
    class Car(NamedTuple):
    color: str
    mileage: float
    automatic: bool
    >>> car1 = Car('red', 3812.4, True)
    # Instances have a nice repr:
    >>> car1
    Car(color='red', mileage=3812.4, automatic=True)
    # Accessing fields:
    >>> car1.mileage
    3812.4
    > # Fields are immutable:
    >>> car1.mileage = 12
    AttributeError: "can't set attribute"
    >>> car1.windshield = 'broken'
    AttributeError:
    "'Car' object has no attribute 'windshield'"
    # Type annotations are not enforced without
    # a separate type checking tool like mypy:
    >>> Car('red', 'NOT_A_FLOAT', 99)
    Car(color='red', mileage='NOT_A_FLOAT', automatic=99)`