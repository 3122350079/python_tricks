# 第六章　循环和迭代

## 6.1 编写python循环

找出最近转Python的开发人员中，具有C语言背景的人员的最简单方法之一就是看他们如何写循环。

例如，如下代码段时，就是有人在尝试用C或Java的风格写Python的一个例子：

    my_items = ['a', 'b', 'c']
    i = 0
    while i < len(my_items):
        print(my_items[i])
        i += 1

现在，这段代码有那些地方不符合Python风格？
两件事情：

首先，它手动维护索引`i`——将其初始化为零，然后在每次循环迭代时增加它。

其次，为了确定迭代次数，它使用len()来获取my_items容器的大小。

在Python中，你可以编写自动处理这两个问题的循环。
充分利用这一点是一个好主意。
例如，如果你不必处理索引，那么就很难编写意外的无限循环。
这也使代码更简洁，因此更具可读性。

为了重构这个代码示例，我将从删除手动更新索引的代码开始。
在Python中，一个好的方法是使用for循环。
使用内置的range()函数，我可以自动生成索引：

    >>> range(len(my_items))
    range(0, 3)
    >>> list(range(0, 3))
    [0, 1, 2]


range类型表示一个不可变的数字序列。
相对于列表来说，它只需要很小的内存。
range对象实际上并不存储代表数字序列的每个值，相反，它是一个迭代器，会实时计算序列值。

因此，与其在每次循环迭代中手动增加i，不如利用range()函数这么写：

    for i in range(len(my_items)):
        print(my_items[i])

这钟写法更好。
但是，它仍然不是很符合Python的风格，
它更像Java式的迭代结构，而不是Python的循环。
当你看到使用range(len(...))遍历容器的代码时，你通常可以进一步简化和改进它。

正如我提过的，在Python中，for循环实际上是for-each循环，
可以直接遍历容器或序列中的项目，而无需按索引查找它们。
我可以用它来简化这个循环：

    for item in my_items:
        print(item)

我认为这种方案是相当符合Python风格的。
它使用了几种先进的Python功能，但仍保持简洁美观，几乎就像编程教科书中的伪代码一样。
请注意一下这个循环是如何不再跟踪容器的大小并且不再使用索引访问元素。

容器本身现在负责产出元素，所以元素才可以被处理。
如果容器有序，则结果也将有序。
如果容器无需，结果也将无序，但循环仍将覆盖所有元素。

当然，你不可能一直可以像这样重写你的循环。
例如，如果你需要元素的索引时，该怎么办？

在不使用range(len(...))这种写法时，也可以编写循环来维护索引。
内置的enumerate()函数可帮助你使这些循环变得美观且符合Python风格：

    >>> for i, item in enumerate(my_items):
    ... print(f'{i}: {item}')
    0: a
    1: b
    2: c

你看，Python中的迭代器可以返回多个值。
他们可以返回具有任意数量元素的元组，然后可以for语句中对元组进行拆包。

这是非常强大的。
例如，你可以使用相同的方法同时遍历字典的键和值：

    >>> emails = {
    ... 'Bob': 'bob@example.com',
    ... 'Alice': 'alice@example.com',
    ... }
    >>> for name, email in emails.items():
    ... print(f'{name} -> {email}')
    'Bob -> bob@example.com'
    'Alice -> alice@example.com'

我想再举一个例子给你看。
如果你就是需要一个C风格的循环，该怎么办？
例如，如果你必须控制索引的步长？
想象一下，你从以下Java循环开始：

    for (int i = a; i < n; i += s) {
    // ...
    }

这种模式如何转换到Python？
range()函数再次救场——它接受可选参数来控制循环的起始值(a)，结束值(n)和步长(s)。

因此，我们的Java循环可以转换成像下面的Python语句：

    for i in range(a, n, s):
        # ...

## 重点

- C风格的循环是不符合Python风格的。尽可能避免手动管理循环的索引和停止条件。
- Python的for循环实际上是for-each循环，它可以直接从容器或序列对元素进行迭代。


## 6.2 解析

我最喜欢的Python功能之一就是列表解析。
他们乍一看似乎有些不可思议，但是当你将它们分解时，它们实际上是一个非常简单的结构。

理解列表解析的关键在于，它们只是用了一种更简洁和紧凑语法对一个数据集进行了for循环。

这有时也称为语法糖，是让我们这些Python程序员更轻松一点的常用功能的简写。
以以下列表解析为例：

    >>> squares = [x * x for x in range(10)]

它计算从零到九的所有整数的平方：

    >>> squares
    [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]

如果你想使用普通的for循环构建相同的列表，则可能需要这样写：

    >>> squares = []
    >>> for x in range(10):
    ...     squares.append(x * x)

那是一个非常简单的循环，对不对？
如果你回过头来比较列表解析的示例和for循环示例，找出共同点，那么最终会总结出一些模式。
通过概括一些常见的结构，你最终将总结出类似于以下的模板：

    values = [expression for item in collection]

上面的列表解析模板等效于下面的普通for循环：

    values = []
    for item in collection:
        values.append(expression)

在这里，我们首先创建一个新的列表实例以接收输出值。
然后，我们遍历容器中的所有元素，用任意表达式对每个元素进行转换，然后将结果添加到输出列表。

这是一个千篇一律的模式，你可以将其应用于许多for循环以将其转化为列表解析，反之亦然。
现在，我们需要在此模板中添加一个更有用的部分，那就是根据条件过滤元素。

列表解析可以基于一些任意条件来过滤值，这些条件决定结果值是否成为输出列表的一部分。
这是一个例子：

    >>> even_squares = [x * x for x in range(10)
                        if x % 2 == 0]

这个列表解析将计算从零到九的整数中所有偶数的平方。
此处使用的模(％)运算符返回一个数字除以另一个后的余数。
在此示例中，我们将使用它来测试数字是否为偶数。
结果如下：

    >>> even_squares
    [0, 4, 16, 36, 64]

与第一个示例类似，这种列表解析也可以转换为等效的for循环：

    even_squares = []
    for x in range(10):
        if x % 2 == 0:
            even_squares.append(x * x)

让我们尝试概括一下列表解析到for循环的转换模式。
这次我们要在模板中添加一个过滤条件，因此我们可以决定最终那个元素会输出到最终的结果列表。
这是更新的列表解析模板：

    values = [expression
    　　　　　　for item in collection
            　if condition]

同样，我们可以将列表解析转换为for循环：

    values = []
    for item in collection:
        if condition:
            values.append(expression)

再一次，这是一个简单的转换——我们只是应用了更新后的模式。
我希望这能消除一些与列表解析如何工作相关的“魔术”。
这是一个所有Python程序员都应该知道如何使用的有效工具。

在继续之前，我想指出Python不仅仅支持列表解析，
还有类似的语法糖用于支持集合和字典。
集合解析如下：

    >>> { x * x for x in range(-9, 10) }
    set([64, 1, 36, 0, 49, 9, 16, 81, 25, 4])

与列表保留了元素的顺序不同，Python集是无序的。
因此，将元素添加到集合中时，结果的顺序将或多或少“随机”过。

这是字典解析：

    >>> { x: x * x for x in range(5) }
    {0: 0, 1: 1, 2: 4, 3: 9, 4: 16}

两者在实践中都是有用的工具。
不过，对于Python的解析有一个警告：
随着你越来越熟练地使用它们，编写难以阅读的代码会变得越来越容易。
一不小心就可能不得不处理可怕的列表，集合和字典。、
请记住，过犹不及。

经过一番苦恼之后，我个人将底线定在一层嵌套的列表解析。
我发现在超过一层嵌套之后，大多数情况下使用for循环效果会更好（“更易读”和“更易于维护”）。

## 重点

- 解析表达式是Python中的关键功能。理解并应用它们将使你的代码更加Pythonic。
- 解析表达式只是for循环的语法糖。了解了模式之后，你会对解析表达式有更深的理解。
- 列表解析之外还有其它的解析表达式。


## 6.3 列表切片技巧

Python的列表对象具有一项巧妙的功能，称为切片。
它是方括号索引语法的扩展。
切片通常用于访问有序集合中一个范围内的元素。
例如，你可以将一个大型列表对象切成多个较小的子列表。

这是一个例子。
切片使用常见的“[]”语法，使用`[start：stop：step]`模式：

    >>> lst = [1, 2, 3, 4, 5]
    >>> lst
    [1, 2, 3, 4, 5]
    # lst[start:end:step]
    >>> lst[1:3:1]
    [2, 3]

添加`[1:3:1]`索引返回原始列表的一部分，这个部分从索引1开始到索引2结束，步长为一个元素。
为了避免边界条件错误，要记住上限永远不包含在内。
这就是为什么`[1:3:1]`切片会返回`[2,3]`子列表的原因。
如果你忽略步长，则默认为一：

    >>> lst[1:3]
    [2, 3]

你还可以使用step参数执行其他有趣的操作。
例如，你可以从原始列表每隔1个元素取一个以创建子列表：

    >>> lst[::2]
    [1, 3, 5]

你刚刚看到切片步长如何用于从原始列表中每隔1个取1个元素。
好吧，还有更多：
如果你使用`[::-1]`切片，你将获得一个原始列表的副本，只是顺序相反：

    >>> numbers[::-1]
    [5, 4, 3, 2, 1]

我们使用(::)要求Python提供一个完整的列表，然后通过将步长设置为-1，从后到前排遍历所有元素。
好整洁，但在大多数情况下，我仍然坚持使用list.reverse()和内置的reversed()函数转列表。

这是另一个列表切片技巧：你可以使用:操作符清除列表中的所有元素，而不会销毁列表对象本身。

当你需要清除程序中具有其他引用指向的列表时，这非常有用。
在这种情况下，你通常不能仅仅通过用新列表对象替换旧列表来清空列表，因为引用不会更新：

    >>> lst = [1, 2, 3, 4, 5]
    >>> del lst[:]
    >>> lst
    []

如你所见，这将删除lst中的所有元素，但列表象本身完好无损。
在Python 3中，你还可以使用lst.clear()实现同样的同能，这可能是更具可读性的模式。
但是，Python 2无法使用clear()。

除了清除列表，你还可以使用`:`操作符在不创建新列表的前提下替换所有元素。
这是一个清除列表，然后手动重新填充它例子：

    >>> original_lst = lst
    >>> lst[:] = [7, 8, 9]
    >>> lst
    [7, 8, 9]
    >>> original_lst
    [7, 8, 9]
    >>> original_lst is lst
    True

前面的代码示例替换了lst中的所有元素，但没有销毁并重新创建列表本身。
之前对列表对象的引用仍然有效。

`:`操作符的另一个用途是创建浅拷贝：

    >>> copied_lst = lst[:]
    >>> copied_lst
    [7, 8, 9]
    >>> copied_lst is lst
    False

创建浅拷贝意味着仅元素的结构被复制，而不是元素本身。
列表的两个副本共享各个元素的相同实例。

如果你需要复制包括元素在内的所有内容，那么你需要创建列表的深拷贝。
Python内置的copy模块可以实现这个功能。

## 重点

- `:`操作符不仅对选择子列表有用，它也可以用于清除，反转，并复制列表。
- 但要小心——这个功能对许多Python开发人员有点神秘，使用它可能会降低你的代码的可维护性。


## 6.4 漂亮的迭代器

与许多其他编程语言的语法相比，Python的语法很简洁。
让我们以`for-in`循环为例。
这样简洁的循环，就好像是一个英语句子：

    numbers = [1, 2, 3]
    for n in numbers:
        print(n)
        
Python这样优雅的循环是如何实现的呢？
循环如何从正在循环的对象中获取每个元素？
在你自己的Python对象中如何才能支持相同的编程风格？

你可以在Python的迭代器协议中找到这些问题的答案：
支持`__iter__`和`__next__`双下划线方法的对象会自动支持for-in循环。

让我们一步步来。
和装饰器一样，迭代器及其的相关技术乍一看非常神秘和复杂。
因此，我们将简化它们。

在本章中，你将看到如何编写多个支持迭代器协议的Python类。
它们是“非魔术”示例，这是你建立并加深理解的一些测试实现。

首先，我们排除任何不必要的环节，把重点放在介绍Python 3中迭代器的核心机制上，
因此你可以清楚地看到迭代器在底层怎么运行。

我会将每个示例都与我们刚开始提到的for-in循环问题联系在一起。
并且，在本章的最后，我们将讨论一些迭代器在Python 2和Python 3之间的差异。

准备好了吗？让我们开始吧！

## 永远迭代

首先，我们从编写一个演示最基本的迭代器协议的类开始。
我在这里使用的示例看起来可能与你在其他迭代器教程中看到的示例不同。
我认为通过这种方式可以让你更了解迭代器在Python中的工作方式。

在接下来的几段中，我们将实现一个名为`Repeater`的类，这个类可以使用for-in循环进行迭代，
如下所示：

    repeater = Repeater('Hello')
    for item in repeater:
        print(item)
    
顾名思义，这个Repeater类的实例在迭代时将重复返回单个值。
所以上面的例子将永远在控制台上输出字符串“Hello”。
首先，我们先定义并实现`Repeater`：

    class Repeater:
        def __init__(self, value):
            self.value = value
            
        def __iter__(self):
            return RepeaterIterator(self)
        
第一次看时，Repeater看起来像是标准的Python类。
但是注意，它还包含了__iter__方法。

我们从__iter__创建并返回的RepeaterIterator对象是什么？
这是为了让for-in迭代示例可以运行需要定义的一个帮助类：

    class RepeaterIterator:
        def __init__(self, source):
            self.source = source
            
        def __next__(self):
            return self.source.value
        
同样，`RepeaterIterator`看起来像一个简单的Python类，
但你可能要注意以下两件事：

  1.在`__init__`方法中，我们将每个`RepeaterIterator`的都链接到创建它的Repeater对象。
  这样我们可以保持被迭代的“源”对象。
  
  2.在`RepeaterIterator.__ next__`中，我们返回到“源”（Repeater实例）并返回它关联的值。
    
在此代码示例中，Repeater和RepeaterIterator一起支持了Python的迭代器协议。
我们定义的两个下划线方法__iter__和__next__是实现Python可迭代对象的关键。

我们接下来会仔细研究这两种方法，我们会对已有的代码进行一些实验，然后看看他们怎么运行。
让我们确认一下这个两个类确实使Repeater对象可以通过for-in循环迭代。
我们将首先创建一个Repeater实例，该实例将一直返回字符串“Hello”：

    >>> repeater = Repeater('Hello')
    
现在，我们尝试使用for-in循环。当你运行以下代码时会发生什么？

    >>> for item in repeater:
    ... print(item)
    
你会看到很多“Hello”输出到屏幕上。
Repeater一直输出同样的字符串到屏幕，并且这个循环永远不会结束。
我们的程序注定要永远打印'Hello'到控制台：

    Hello
    Hello
    Hello
    Hello
    Hello
    ...
    
恭喜——你刚刚用Python写了一个可以运行的迭代器，并且和for-in循环一起使用。
循环可能还没有结束……但是到目前为止，没有什么问题。

接下来，我们将梳理这个示例，以了解__iter__和__next__方法如何让Python对象可迭代。

提示：如果你运行了最后一个示例，现在想要停止它，请按几次 `Ctrl + C` 以摆脱无限循环。

### for-in循环在Python中如何工作？

很明显我们的Repeater类支持迭代器协议，我们运行了一个for-in循环来证明它：

    repeater = Repeater('Hello')
    for item in repeater:
        print(item)

现在，这个for-in循环在底层做了什么？
它是如何与`Repeater`对象通信并从中获取新元素的？

为了消除某些“魔法”，我们可以将此循环扩展为一个长一点的版本，两者具有相同的结果：

    repeater = Repeater('Hello')
    iterator = repeater.__iter__()
    while True:
        item = iterator.__next__()
        print(item)

如你所见，for-in只是一个简单`while`循环的语法糖：

- 它首先通过调用`__iter__`方法让`repeater`对象准备进行迭代。这返回了实际的迭代器对象。
- 之后，循环反复调用迭代器对象的`__next__`方法从中检索值。

如果你使用过数据库游标，这个思维模型看起来会很熟悉：
我们首先初始化游标并准备进行读取，
然后我们可以根据需要将数据读取到局部变量中，一次一个元素。

因为正在处理中的元素不超过一个，所以这种方法具有很高的内存使用效率。
我们的Repeater类提供了一个无限的元素序列，我们可以对其进行迭代。
用Python列表模拟同样的事情是不可能的——
我们不可能一开始就创建一个具有无限元素的列表。
这使得迭代器成为一个非常强大的概念。

用更抽象的术语讲，迭代器提供了一个通用接口，
它可让你在与容器的内部结构完全隔离的情况下，处理容器的每个元素。

无论你要处理的是列表，字典，无限序列（比如Repeater类提供的这种）或其它序列类型——所有这些都只是实现细节。 每一个
每个这种对象，都可以使用迭代器以相同的方式进行遍历。

如你所见，在Python中for-in循环并没有什么特别的。
如果你探究一下底层的原理，归根结底是在正确的时间调用正确的双下划线方法。
实际上，你可以在Python解释器会话中手动“模拟”循环如何使用迭代器协议：

    >>> repeater = Repeater('Hello')
    >>> iterator = iter(repeater)
    >>> next(iterator)
    'Hello'
    >>> next(iterator)
    'Hello'
    >>> next(iterator)
    'Hello'
    ...

这输出了相同的结果——无限的`Hello`流。
每次你调用`next()`时，迭代器都输出相同的问候。

顺便说一下，我在这里用Python内置函数`iter()`和`next()`取代了对`__iter__`和`__next__`的调用。

在内部，这些内置函数调用相同的双下划线方法，
但是通过提供一个迭代器协议的整洁“门面”，它们让代码更整洁，更易读。

Python还为其它方法提供了快捷方式。
例如，`len(x)`是调用`x.__ len__`的快捷方式。
相似地，调用`iter(x)`最终会调用`x.__iter__`，
调用`next(x)`最终会调用`x.__ next__`。

通常，最好使用内置的函数，而不是直接调用实现协议的双下划线方法。
它会使代码更易于阅读。

### 一个简单的迭代类

到目前为止，我们的迭代器示例由`Repeater`和`RepeaterIterator`两个单独的类组成。
他们直接对应于Python的迭代器协议的两个阶段：

首先，通过调用`iter()`创建迭代器对象，
然后通过`next()`从中获取值。

很多时候，这两项职责可以由一个类承担。
在编写基于类的迭代器时，这样做可以减少所需的代码量。

我不选择在本章的第一个示例这么做，
是因为它让迭代器协议背后的心理模型不再清晰。
但是现在你已经了解了如何用更长，更复杂的方法编写基于类的迭代器，
接下来让我们花一点时间来简化一下我们目前的代码。

还记得为什么我们需要`RepeaterIterator`类吗？
我们需要它来承载`__next__`方法以从迭代器中获取新值。
但是`__next__`在哪里定义并不重要。
在迭代器协议中，重要的是`__iter__`要返回带有`__next__`方法的对象。

所以这里有个想法：`RepeaterIterator`一直返回相同的值，不必跟踪任何内部状态。
如果我们直接将`__next__`方法添加到`Repeater`类中会怎么样？

这样，我们可以完全摆脱`RepeaterIterator`，并用单个Python类实现一个可迭代的对象。
让我们试试！我们新的简化后的迭代器示例如下：

    class Repeater:
        def __init__(self, value):
            self.value = value
            
        def __iter__(self):
            return self
            
        def __next__(self):
            return self.value

我们从10行代码的两个单独的类简化到了7行代码的一个类。
我们简化的实现仍然很好地支持迭了代器协议：

    >>> repeater = Repeater('Hello')
    >>> for item in repeater:
    ... print(item)
    Hello
    Hello
    Hello
    ...

简化这样基于类的迭代器通常很有意义。
实际上，大多数Python的迭代器教程都是以这种方式开始的。
但是我总是觉得从一开始就用一个类来解释迭代器没有揭示迭代器协议的底层的原理，
因此使其难以理解。

## 谁想一直迭代

现在，你应该对Python迭代器的工作方式有一个很好的理解。
但是到目前为止，我们仅实现了一直迭代的迭代器。

显然，无限重复并不是迭代器的主要使用场景。
实际上，当你从头到尾回顾整个过程时，在本章中，我使用以下代码段作为开始的示例：

    numbers = [1, 2, 3]
    for n in numbers:
        print(n)

你会期望上面的代码打印数字1、2和3，然后停下来。
你不会期望它在你的终端一直打印“3”，直到你在慌乱中使用了Ctrl + C…

因此，是时候看看怎么编写最后能够停止生成新值，而不是永远迭代下去的迭代器了，
因为那才是我们在for-in循环中使用迭代器时典型的表现。

现在，我们来编写另一个迭代器类，称为`BoundedRepeater`。
它与之前的`Repeater`示例相似，但是这次我们希望它在预设的重复次数后停止。

让我们考虑一下。
我们如何做到这一点？迭代器如何在没有元素要迭代时发出信号？
也许你在想，“嗯，我们可以在`__next__`方法返回None。”

那不是一个坏主意，但问题是，如果我们希望某些迭代器能够返回None做为可接受的值时应该怎么办？

让我们看看其他迭代器是怎么解决这个问题的。
我将构造一个简单的容器，一个包含一些元素的列表，然后我将对其进行迭代，直到用完所有元素以查看发生了什么事情：

    >>> my_list = [1, 2, 3]
    >>> iterator = iter(my_list)

    >>> next(iterator)
    1
    >>> next(iterator)
    2
    >>> next(iterator)
    3

注意！我们已经使用了列表中的仅有的三个可用元素。
看看如果再次在迭代器上调用`next`会发生什么：

    >>> next(iterator)
    StopIteration

啊哈！它将抛出StopIteration异常，表明我们已经耗尽了迭代器中所有可用的值。

没错：迭代器使用异常来构造控制流。
Python迭代器通过抛出内置StopIteration异常，表示迭代结束。

如果我不断要求迭代器提供更多值，它将不断抛出StopIteration异常，以表示没有更多值可迭代了：

    >>> next(iterator)
    StopIteration
    >>> next(iterator)
    StopIteration
    ...

一旦耗尽，Python迭代器通常无法“重置”，他们应该在每次调用next()时抛出StopIteration异常。
如果要重新进行迭代，需要使用iter()函数构造一个新的迭代器对象。

现在我们知道编写`BoundedRepeater`类所需的一切了，它会在设定的重复次数后停止迭代：

    class BoundedRepeater:
        def __init__(self, value, max_repeats):
            self.value = value
            self.max_repeats = max_repeats
            self.count = 0

        def __iter__(self):
            return self

        def __next__(self):
            if self.count >= self.max_repeats:
                raise StopIteration
            self.count += 1
            return self.value

这给出了我们想要的结果。
迭代器在迭代了`max_repeats`参数定义的迭代次数后停止了：

    >>> repeater = BoundedRepeater('Hello', 3)
    >>> for item in repeater:
        print(item)
    Hello
    Hello
    Hello

如果我们去掉语法糖，重写这个for-in循环示例，我们得到了下面展开后的代码片段：

    repeater = BoundedRepeater('Hello', 3)
    iterator = iter(repeater)
    while True:
        try:
            item = next(iterator)
        except StopIteration:
            break
        print(item)

每次在此循环中调用`next()`时，我们都会检查StopIteration异常，并在必要时中断while循环。

能够编写三行的for-in循环而不是八行的while循环是一个不错的改进。
它使代码更容易阅读且更易于维护。
这是Python中迭代器如此强大的另一个原因。

## Python2.x 兼容

我在这里展示的所有代码示例都是用Python 3编写的。
在实现基于类的迭代器时，Python 2和3之间的区别很小但却很重要：

- 在Python 3中，从迭代器获取下一个值的方法称为`__next__`。
- 在Python 2中，相同的方法称为`next`（不带下划线）。

如果你尝试编写应该在两种版本的Python上都可以使用的基于类的迭代器，这种命名差异可能会导致一些问题。
幸运的是，你可以采用一种简单的方法来绕过这种差异。

这是InfiniteRepeater类的更新版本，
适用于Python 2和Python 3：

    class InfiniteRepeater(object):
        def __init__(self, value):
            self.value = value
        
        def __iter__(self):
            return self
        
        def __next__(self):
            return self.value
        
        # Python 2 compatibility:
        def next(self):
            return self.__next__()

为了使该迭代器类与Python 2兼容，我对其做了两个小改进：

首先，我添加了一个next方法，该方法仅调用原始的__next__并转发其返回值。
这实际是现有的__next__实现的别名，这样Python 2就可以找到它。
这样我们就可以支持两个版本的Python，同时所有实现细节仍然集中在一处。

其次，我修改了类定义，让类继承自object，确保我们在Python 2上创建的是新式类。
这与迭代器没有任何关系，但尽管如此这是一个好习惯。

## 重点

- 迭代器为Python对象提供了一个序列接口，它具有很高的内存使用效率，并且是Pythonic的。看漂亮的for-in循环！
- 为了支持迭代，对象需要提供`__iter__`和`__next__`双下划线方法来实现迭代器协议。
- 基于类的迭代器只是在Python中编写可迭代对象的一种方法。还有生成器和生成器表达式。

