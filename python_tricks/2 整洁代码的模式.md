## 2.1 使用断言, # TODO
有时候,一些真正有用的语言特性往往没有得到应有的重视. Python的`assert`语句就是如此

在这一章我将会介绍如何使用Python的断言.你会学到如何使用断言自动捕获代码中的错误,
这会增加代码的可读性,会让你的代码更加容易调试.

在这个点上,你可能会疑惑,"什么是断言,断言有什么好处?"

Python的断言可以测试一个条件以辅助调试.如果断言的条件是true,什么都不会发生,代码继续正常执行.
但是如果条件是false,会抛出一个`AssertionError`的异常,这个异常可以添
加一个可选的错误信息


## Python中断言的一个例子
在这个简单的例子中,你可以看到断言的作用.我尽量使这个例子和真实世界中你可能遇到
的问题更相似

假设你在使用Python搭建一个在线商店.你写下了下面的apply_discount函数为系统添加一
个打折优惠的功能.

    `def apply_discount(product, discount):

         price = int(product['price'] * (1.0 - discount))

         assert 0 <= price <= product['price']

         return price`


上面函数中的assert语句会保证在任何情况下,经过这个函数计算后的打折后的价格都不会比0更低,不会比初始价格更高.

让我们确认一下,在我们调用这个函数计算一个折扣的时候,这个逻辑确实按照我们设想的方式工作.
在这个例子中,我们商店中的商品会使用字典进行表示.这很可能和你在真实应用中的做法不同,
但是对于演示断言,这已经足够了.我们先创建一个商品当做例子,这个商品是一双价值$149的漂亮鞋子

    `shoes = {'name': 'Fancy Shoes', 'price': 14900}`

##TODO
顺便说一下,你有没有注意到我通过使用整数表示以分为单位的价格避免了找零时的四舍五入问题?这是一个好主意,
但是我不这么认为,现在,如果给予25%的折扣,我们期望的销售价格就会到$111.75

    `apply_discount(shoes, 0.25)
    >>> 11175`

一切正常.现在我们试试一些无效的折扣,比如200%的折扣,将会让我们倒付钱给消费者
    `>>> apply_discount(shoes, 2.0)`

    `Traceback (most recent call last):
    
    File "<input>", line 1, in <module>
    
    apply_discount(prod, 2.0)
    
    File "<input>", line 4, in apply_discount
    
    assert 0 <= price <= product['price']
    
    AssertionError`

如你所见,当我门尝试打一个无效的折扣的时候,我们的程序抛出了一个`AssertionError`.
之所以会这样是因为200%的折扣违反了我们在`apply_discount`函数中的断言条件
你还能看到异常错误栈指出了包含失败断言的哪一行代码,如果你(或者你们团队的其它开发者)在测试在线商店的时候遇到了这样的一个错误,
通过错误栈会很容易找到具体发生了什么

这会在很大成都上加快调试的速度,并且会让你的代码更易于维护.这就是断言的力量


## 为什么不直接使用一个常规的异常
你可能会疑惑为什么在上面的例子中我不直接使用`if`语句抛出一个异常.

正确使用断言可以通知开发者那些程序中不可恢复的错误.断言不是为了提示预期中的错误,
对于像文件没找到这种预期中的错误,用户可以采取纠正措施,或者直接重试

断言意味着程序的内部自检.断言会声明一些不可能发生的条件,如果这些条件没有被兜住,
意味着代码中存在bug

如果你的代码没有任何bug, 这些断言条件永远不会发生.但是一旦发生,程序就会崩溃,此时会抛出一个断言错误,
告诉你哪个"不可能"的条件被触发了.
这会让定位和修复bug变得简单.我喜欢任何让生活变得简单的事情--难道你不是吗?

到目前位置,牢记Python的断言是一个调试的辅助工具,不是一套处理运行时错误的机制.
使用断言是为了让开发者能够更快发现可能导致bug的根源.
如果程序没有bug,断言错误永远不应该被主动抛出

让我们看一下可以用断言做的其它事情,后面我将会列出2个实践中常见的陷阱


## Python的断言语法
在使用一个Python的特性之前,最好学习一下它是怎样实现的.我们快速看看Python文档中断言的语法

    `assert_stmt ::= "assert" expression1 ["," expression2]`

在这个例子中, expression1 是我们测试的条件, 可选的expression2 是一个断言失败后显示的错误信息.
在执行时,Python解释器吧每个断言转换成大致如下的语句:

    `if __debug__:
        if not expression1:
        raise AssertionError(expression2)`

这段代码里面有两件很有趣的事情:

在断言条件检查之前,对全局变量__debug__进行了额外的检查.__debug__是一个内建的bool值,
正常情况下这个值是true,如果需要优化,这个值是false
在后面常见陷阱部分,我们会对这个问题进行更深入的讨论


