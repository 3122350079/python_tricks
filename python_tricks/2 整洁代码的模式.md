## 2.1 使用断言, # TODO
有时候,一些真正有用的语言特性往往没有得到应有的重视. Python的`assert`语句就是如此

在这一章我将会介绍如何使用Python的断言.你会学到如何使用断言自动捕获代码中的错误,
这会增加代码的可读性,会让你的代码更加容易调试.

在这个点上,你可能会疑惑,"什么是断言,断言有什么好处?"

Python的断言可以通过测试一个条件辅助调试.如果断言的条件是true,什么都不会发生,代码继续正常执行.
但是如果条件是false,会抛出一个`AssertionError`的异常,这个异常可以添加一个可选的错误信息


## Python中断言的一个例子
在这个简单的例子中,你可以看到断言的作用.我尽量使这个例子和真实世界中你可能遇到的问题更相似

假设你在使用Python搭建一个在线商店.你写下了下面的apply_discount函数为系统添加一个打折优惠的功能.

    `def apply_discount(product, discount):

         price = int(product['price'] * (1.0 - discount))

         assert 0 <= price <= product['price']

         return price`


上面函数中的assert语句会保证在任何情况下,经过这个函数计算后的打折后的价格都不会比0更低,不会比初始价格更高.

让我们确认一下,在我们调用这个函数计算一个折扣的时候,这个逻辑确实按照我们设想的方式工作.
在这个例子中,我们商店中的商品会使用字典进行表示.这很可能和你在真实应用中的做法不同,
但是对于演示断言,这已经足够了.我们先创建一个商品当做例子,这个商品是一双价值$149的漂亮鞋子

    `shoes = {'name': 'Fancy Shoes', 'price': 14900}`

##TODO

顺便说一下,你有没有注意到我通过使用整数表示以分为单位的价格避免了找零时的四舍五入问题?这是一个好主意,
但是我不这么认为,现在,如果给予25%的折扣,我们期望的销售价格就会到$111.75

    `apply_discount(shoes, 0.25)
    >>> 11175`

一切正常.现在我们试试一些无效的折扣,比如200%的折扣,将会让我们倒付钱给消费者
    `>>> apply_discount(shoes, 2.0)`

    `Traceback (most recent call last):
    
    File "<input>", line 1, in <module>
    
    apply_discount(prod, 2.0)
    
    File "<input>", line 4, in apply_discount
    
    assert 0 <= price <= product['price']
    
    AssertionError`

如你所见,当我门尝试打一个无效的折扣的时候,我们的程序抛出了一个`AssertionError`.
之所以会这样是因为200%的折扣违反了我们在`apply_discount`函数中的断言条件
你还能看到异常错误栈指出了包含失败断言的哪一行代码,如果你(或者你们团队的其它开发者)在测试在线商店的时候遇到了这样的一个错误,
通过错误栈会很容易找到具体发生了什么

这会在很大成都上加快调试的速度,并且会让你的代码更易于维护.这就是断言的力量


## 为什么不直接使用一个常规的异常
你可能会疑惑为什么在上面的例子中我不直接使用`if`语句抛出一个异常.

正确使用断言可以通知开发者那些程序中不可恢复的错误.断言不是为了提示预期中的错误,
对于像文件没找到这种预期中的错误,用户可以采取纠正措施,或者直接重试

断言意味着程序的内部自检.断言会声明一些不可能发生的条件,如果这些条件没有被兜住,
意味着代码中存在bug

如果你的代码没有任何bug, 这些断言条件永远不会发生.但是一旦发生,程序就会崩溃,此时会抛出一个断言错误,
告诉你哪个"不可能"的条件被触发了.
这会让定位和修复bug变得简单.我喜欢任何让生活变得简单的事情--难道你不是吗?

到目前位置,牢记Python的断言是一个调试的辅助工具,不是一套处理运行时错误的机制.
使用断言是为了让开发者能够更快发现可能导致bug的根源.
如果程序没有bug,断言错误永远不应该被主动抛出

让我们看一下可以用断言做的其它事情,后面我将会列出2个实践中常见的陷阱


## Python的断言语法
在使用一个Python的特性之前,最好学习一下它是怎样实现的.我们快速看看Python文档中断言的语法

    `assert_stmt ::= "assert" expression1 ["," expression2]`

在这个例子中, expression1 是我们测试的条件, 可选的expression2 是一个断言失败后显示的错误信息.
在执行时,Python解释器吧每个断言转换成大致如下的语句:

    `if __debug__:
        if not expression1:
        raise AssertionError(expression2)`

这段代码里面有两件很有趣的事情:

在断言条件检查之前,对全局变量__debug__进行了额外的检查.__debug__是一个内建的bool值,
正常情况下这个值是true,如果需要优化,这个值是false
在后面常见陷阱部分,我们会对这个问题进行更深入的讨论

你还可以使用expression2传入一个用于在断言异常错误栈中显示的错误信息。
## TODO, 润色一下这里
这可以用于一些更深入的调试，比如下面的例子

    `if cond == 'x':
     ... do_x()
     elif cond == 'y':
     ... do_y()
     else:
     ... assert False, (
     ... 'This should never happen, but it does '
     ... 'occasionally. We are currently trying to '
     ... 'figure out why. Email dbader if you '
     ... 'encounter this in the wild. Thanks!')`
     
这确实是一种丑陋的写法，但在你遇到难以复现的bug的时候，这确实是一种有用的方法。


## Python中断言的常见陷阱

在继续之前，我还像指出两个和Python中断言相关的重要警告。
第一个和引入安全问题和bug有关，第二个和很容易写出无用断言的奇怪语法有关。

这听起来很恐怖，所以你最好至少遵守下面的两个警告

## 警告1：不要用断言进行数据验证

在使用Python断言时最大的警告：断言可以通过-0和--0命令行开关进行全局禁用，
CPython中的PYTHONOPTIMIZE环境变量也可以禁用断言

这会将所有的断言语句变成空操作：断言会在编译时被排除，并且永远不会被评估，这意味着没有任何断言会被执行

这是一个设计决策，在很多其它编程语言中也有类似的决策。
这种行为的副作用就是，使用断言对输入数据进行快速验证是极度危险的。

如果你的代码使用断言检查函数的参数是否包含一个"错误"的或者不在预期之内的值,
这可能会适得其反,导致一些bug或者安全漏洞.

让我们用一个简单例子说明这个问题. 假设你在使用Python搭建一个在线商城. 
在你应用的某个地方有一个函数根据用户的请求删除产品.

因为你刚刚学过断言,所以你很渴望在代码中使用断言,你写下了下面的代码.

    `def delete_product(prod_id, user):
        assert user.is_admin(), 'Must be admin'
        assert store.has_product(prod_id), 'Unknown product'
        store.get_product(prod_id).delete()`


仔细看看这个`delete_product`函数,如果断言被禁用,将会发生什么?

在这个三行代码的函数中,有两个很严重的问题,它们都是因为不正确地使用断言导致的.

- 使用断言检查管理员权限是很危险的. 如果在Python解释器中,断言被禁用,这将变成一个空操作.
所以任何人都可以删除产品.权限检查的代码甚至根本没有运行.这很有很能引入安全问题, 
  并且为攻击者摧毁或者严重损坏我们在线商城的数据打开大门.这不是一个好的用法.
  
- `has_product()`检查在断言禁用的时候会直接跳过.
  这意味着`get_product()`可以通过无效的产品id进行调用--这会导致更严重的bug.
  在最坏的情况下,这很可能是一个导致服务拒绝攻击的途径.
  比如,可能商城崩溃了,可能有人尝试删除了一个未知的商品,一个攻击者可能会通过无效的删除请求进行轰炸,进而导致服务中断.
  
我们怎么避免这些问题呢?答案就是永远不要使用断言进行数据验证.我们可以使用常规的if语句进行验证,在必要的时候抛出验证异常,比如:

    `def delete_product(product_id, user):
        if not user.is_admin():
        raise AuthError('Must be admin to delete')
        if not store.has_product(product_id):
        raise ValueError('Unknown product id')
        store.get_product(product_id).delete()`

这个更新后的例子还有一个好处: 
它现在抛出像ValueError或者AuthError(我们必须自己定义)这类语义上正确地异常,
而不是抛出一个不明确的断言异常.


## 警告2: 永不失败的断言

偶然写出永远为真的Python断言是一件相当容易的事情.我在过去就尝到过这样的苦果.
## TODO 补充一句

当你将元祖做为第一个函数传给断言的时候,断言总是为真,从不失败.
下面的这个例子中断言永远不会失败.

    `assert(1 == 2, 'This should fail')`

这和Python中不为空的元祖总是为真有关.
如果你传一个元祖给一个断言,会导致断言条件永远是真--进而导致上面的断言语无效,
因为断言语句永远不会失败,永远不会出发一个异常.

相对来说很容易因为直觉行为写出这种多行的糟糕断言。
比如，我很快乐的在我的一个测试套件中写了一堆无用的测试用例，这些用例给人以一种错误的安全感。
想象一下在你的一个单元测试中有如下的断言。

    `assert (
     counter == 10,
     'It should have counted all the items'
     )`
     
在第一次检测的时候，这个测试案例看起来没有任何问题。
然而它永远不会捕获错误的结果：无论变量counter的值为何，断言总是为真。
为什么会这样呢？因为它在对一个值为真的元组进行断言。

就像我说过的，这种做法很容易砸到自己的脚。一个很好的防止这种奇怪预发引起麻烦的对策是使用[code linter](https://dbader.org/blog/catching-bogus-python-asserts)
Python3的新版本会对这种模糊的断言给出警告。

顺便说一句，这就是为什么你应该始终对单元测试用例进行快速烟雾测试的原因。
确保它们确实可以失败然后继续写下一个。


## Python断言--总结

除了这些经过，我坚信Python的断言是一个没有被Python开发者充分使用的调试工具。

懂得断言怎么工作，在什么时候使用断言可以帮助你写出更容易维护的和更容易调试的代码。

这是一项很棒的学习技能，它可让你的Python知识更进一步，使你成为更全面的Pythonista。
我知道它节省了我数小时的调试工作。


## 重点
- Python的assert语句是一种调试辅助工具，可以使用内部自检的方式测试一个条件。
- 断言仅应用于帮助开发人员识别错误。它们不是用于处理运行时错误的机制。
- 可以通过解释器设置在全局禁用断言。


## 2.2 逗号放置  #TODO: 润色

当你在Python中的列表，字典或集合中增删元素的时候，有一个有用的建议：以逗号作为所有行的结尾。

不确定我在说什么?让我来给出一个例子.想象一下你在代码里面有这样一个名字的列表.

    `>>> names = ['Alice', 'Bob', 'Dilbert']`

当你修改这个列表的时候，通过git的diff命令很难看到具体修改了什么。
很多的源码管理系统是基于行的，很难凸显在一行中的多出修改。

一个快速的解决方法是采用一种更新的代码风格，将列表，字典，集合像下面这样展开到多个行。

    `>>> names = [
        ... 'Alice',
        ... 'Bob',
        ... 'Dilbert'
        ... ]`

这样每一行就只有一个元素，添加，修改，删除一个元素在代码管理系统中很容易通过diff进行显示。
这是一个简单的改动，但是帮我避免了愚蠢的错误。这也让我团队的同事在review我的代码的时候更加轻松。

现在还有两个涉及到编辑的情况会引起困惑。当你在列表的末尾添加一个元素，或者你删除了最后一个元素，
你不得不修改逗号的位置以保持统一的代码风格。

比如你想要在列表添加另一个名字（_Jane_）。
如果你添加了*Jane*，你就需要修改在*Dilbert*这一行所在的逗号来避免错误。

    `>>> names = [
        ... 'Alice',
        ... 'Bob',
        ... 'Dilbert' # <- Missing comma!
        ... 'Jane'
        ]
        `

当你检查列表的内容时，你可能会感到惊奇：

    `>>> names
        ['Alice', 'Bob', 'DilbertJane']`

如你所见，Python把字符串*Dilbert*和*Jane*合并成了一个新的字符串`DilbertJane`。
这种所谓的“字符串字面串联”是有意设计的，在文档里也有说明。
这是一种音符难以捕获的bug到代码中，搬起石头砸自己的脚的匪夷所思的方式。

> 多个相邻的字符或者字节（使用空格分割）是允许的，
> 他们可能使用不同的引号，它们的意义和它们的连接体是一样的。

字符串字面连接在某些情况下还是一个有用的特性。比如，你可以用它减少分割长字符串到多个行时需要的反斜杆。

    `my_str = ('This is a super long string constant '
               'spread out across multiple lines. '
               'And look, no backslash characters needed!')`

另一方面，我们刚刚看到相同的功能如何快速导致一种问题。现在我们怎么解决这个问题？

在*Dilbert*行后面添加逗号会防止两个字符拼接成一个。
    
    `>>> names = [
        ... 'Alice',
        ... 'Bob',
        ... 'Dilbert',
        ... 'Jane'
        ]`

但是现在我们绕了一圈又回到了原点。为了添加一个新的名字到列表，我必须修改两行。
这导致在`git diff`时很难看到什么被修改了。是有人添加了一个新的名字，还是有人修改了*Dilbert*的名字？

幸运的是，Python的语法允许一些回旋余量来一劳永逸地解决这个逗号放置的问题。
你只需要训练自己采用一种在一开始就避免它的代码风格。让我具体来解释。

在Python中，你可以在列表，字典，集合中为每一个元素（包含最后一个元素）后面都添加一个逗号，
你只需要记得让每一行都使用逗号结尾，这样你就可以避免对是否放置逗号的判断。

最终的例子如下：
    
    `>>> names = [
        ... 'Alice',
        ... 'Bob',
        ... 'Dilbert',
        ... ]`

你有没有注意到Dilbert这一行最后的逗号，这样可以在新增或者删除元素的时候不必在更新逗号的位置。
这让你的代码保持一致，代码管理系统的diff操作更加清晰明了，代码评审的同事更加开心。
有时候，魔法藏在细节中，不是吗？

## 重点
- 合理的代码风格和逗号放置可以使你的列表，字典，或集合更容易维护
- Python 的字符串字面连体功能可以带来好处，也可能引入难以捕捉的错误。


## 2.3 上下文管理器和with语句

Python中的`with`语句有时候被当做一种晦涩的难懂的特性。
但是当你明白了其中的原理的时候，你会发现其中并没有什么魔法，
并且实际上`with`语句是一个帮你写出整洁和易读代码的很有用的特细没买过。

那么with语句有什么用呢？通过抽象资源的功能，
with语句有助于简化某些常见的资源管理模式并允许将它们分解和重用。

一个很好的看到有效地使用此功能的方法是查看Python标准库中的示例。
内置的`open()`函数为我们提供了一个很好的用例：

    `with open('hello.txt', 'w') as f:
        f.write('hello, world!')`
        
通常推荐使用with语句打开文件，因为它可以确保在程序执行with语句的上下文后自动关闭打开文件描述符。
最后，上面的代码示例转换为如下形式：

    `f = open('hello.txt', 'w')
     try:
        f.write('hello, world')
     finally:
        f.close()`
        
你已经可以会说这有点冗长。但是请注意`try ... finally`语句很重要。像下面这样写是不够的。
    
    `f = open('hello.txt', 'w')
     f.write('hello, world')
     f.close()`
     
如果在f.write()调用期间发生异常，这种实现将不能保证文件一定被关闭，因此我们的程序可能导致文件描述符泄漏。
这就是with语句如此有用的原因。它使获取和释放资源变得轻而易举。

另一个with语句被用于标准库很好的例子是threading.Lock类：

    `some_lock = threading.Lock()
     # Harmful:
     some_lock.acquire()
     try:
        # Do something...
     finally:
        some_lock.release()
     
     # Better:
     with some_lock:
        # Do something...`


在这两种情况下，使用with语句可以抽象出大部分资源处理逻辑。
不必每次都写一个try... finally语句，可以使用with语句帮我们做这些事情。

with语句可以使处理系统资源的代码更具可读性。
通过使自动清理或释放资源不再需要的资源，还可以帮助你避免错误或资源泄漏。

## 在你自己的对象中支持with语句

open()函数或threading.Lock类以及它们可以使用with语句没有任何特殊的地方或者魔法。
你可以通过实现所谓的上下文管理器来为自己的类和函数提供相同的功能。

什么是上下文管理器？这是一个对象要支持with语句需要遵从的简单“协议”。
如果你想让一个对象充当上下文管理器，你所需要做的就是在你的对象中添加__enter__和__exit__方法。
Python将在资源管理周期的适当时间调用这两个方法。

让我们看一下实际情况。一个简单实现的open()上下文管理器可能像下面这样：

    `class ManagedFile:
        def __init__(self, name):
            self.name = name
         
        def __enter__(self):
            self.file = open(self.name, 'w')
            return self.file
         
        def __exit__(self, exc_type, exc_val, exc_tb):
            if self.file:
                self.file.close()`

就像原始的open()示例做的，现在我们的ManagedFile类遵循了上下文管理器协议，支持了with语句：

    `>>> with ManagedFile('hello.txt') as f:
        ... f.write('hello, world!')
        ... f.write('bye now')`


当进入上下文时，Python调用`__enter__`获取资源。 当离开上下文时，Python调用`__exit__`释放资源。

编写基于类的上下文管理器并不是唯一支持with语句的方式。
标准库中的`contextlib`模块提供了一些基本的上下文管理器协议之上的抽象。
如果你的使用场景与`contextlib`所提供的相匹配，使用它会更简单一点。

例如，你可以使用`contextlib.contextmanager`装饰器为资源定义基于生成器的工厂函数，该函数将自动支持with语句。
下面是我们使用这种技术重写的`ManagedFile`上下文管理器示例：

    `from contextlib import contextmanager
     @contextmanager
     def managed_file(name):
         try:
            f = open(name, 'w')
            yield f
        finally:
            f.close()

    >>> with managed_file('hello.txt') as f:
    ... f.write('hello, world!')
    ... f.write('bye now')`


在这种情况下，`managed_file()`是一个生成器，它首先获取资源，
之后，它会暂时中止自己的执行，在yield处产生资源，以便调用者可以使用它。
当调用者离开with上下文，生成器继续执行，以执行剩余的清理步骤，将资源释放。

基于类的实现和基于生成器的实现本质上是等效的。
你可能更喜欢一个，具体取决于你认为哪种方法更具可读性。

基于@contextmanager的实现的缺点可能是它需要对Python的高级概念有一些了解，例如装饰器和生成器。
如果你需要获取相关的只是，请随意阅读本书中的相关章节。

再强调一次，在这里做出正确的选择取决于你和你的团队习惯使用什么以及你认为什么是最易读的。

###　使用上下文管理器编写漂亮的接口

上下文管理器非常灵活，如果你创造性地使用with语句，则可以为模块和类定义便捷的API。
例如，如果我们要管理的“资源”是某种报告生成器程序中的文本缩进级别，我们可以这样编写代码：

    `with Indenter() as indent:
        indent.print('hi!')
        with indent:
            indent.print('hello')
            with indent:
                indent.print('bonjour')
        indent.print('hey')`

这几乎就像用于缩进文本的特定领域的语言（DSL）一样。
另外，请注意代码如何多次进入和离开同一个上下文管理器以更改缩进级别。
运行该代码段会得到以下输出并整齐地将格式化文本输出到控制台：

    `hi!
        hello
            bonjour
    hey`

那么，你将如何实现上下文管理器来支持此功能？

顺便说一句，这可能是一个很好的练习机会，可以让你准确了解上下文管理器如何工作。
因此，在你查看下面的实现之前，你最好将其作为一个练习，花一些时间并尝试实现这个功能。

如果你准备查看我的实现，这里是一个使用基于类的上下文管理器实现此功能：

    `class Indenter:
     def __init__(self):
     　  self.level = 0
    
    def __enter__(self):
    　   self.level += 1
    　   return self
    
    def __exit__(self, exc_type, exc_val, exc_tb):
        self.level -= 1
        def print(self, text):
        print(' ' * self.level + text)`


那还不错，不是吗？ 我希望到现在为止你已经感觉到在Python程序使用上下文管理器和的with语句更舒适。
它们是一项出色的特性，可让你以更加符合Python风格的方式管理资源，并且让代码更易于维护。

如果你正在寻找另一个练习来加深理解，尝试实现一个使用time.time函数测量执行时间的上下文管理器。
一定要尝试同时编写基于装饰器和基于类的变体以理解两者之间的区别。

### 重点

- with语句通过将`try/finally`语句的标准用法封装在所谓的上下文管理器中简化异常处理。
- 最常见的是用于安全地获取和释放系统资源。进入with语句时自动获取资源离开with语句时自动释放资源。
- 有效使用上下文管理器可以帮助你避免资源泄漏并且使你的代码更易于阅读。









