## 2.1 使用断言, # TODO
有时候,一些真正有用的语言特性往往没有得到应有的重视. Python的`assert`语句就是如此

在这一章我将会介绍如何使用Python的断言.你会学到如何使用断言自动捕获代码中的错误,
这会增加代码的可读性,会让你的代码更加容易调试.

在这个点上,你可能会疑惑,"什么是断言,断言有什么好处?"

Python的断言可以通过测试一个条件辅助调试.如果断言的条件是true,什么都不会发生,代码继续正常执行.
但是如果条件是false,会抛出一个`AssertionError`的异常,这个异常可以添加一个可选的错误信息


## Python中断言的一个例子
在这个简单的例子中,你可以看到断言的作用.我尽量使这个例子和真实世界中你可能遇到的问题更相似

假设你在使用Python搭建一个在线商店.你写下了下面的apply_discount函数为系统添加一个打折优惠的功能.

    `def apply_discount(product, discount):

         price = int(product['price'] * (1.0 - discount))

         assert 0 <= price <= product['price']

         return price`


上面函数中的assert语句会保证在任何情况下,经过这个函数计算后的打折后的价格都不会比0更低,不会比初始价格更高.

让我们确认一下,在我们调用这个函数计算一个折扣的时候,这个逻辑确实按照我们设想的方式工作.
在这个例子中,我们商店中的商品会使用字典进行表示.这很可能和你在真实应用中的做法不同,
但是对于演示断言,这已经足够了.我们先创建一个商品当做例子,这个商品是一双价值$149的漂亮鞋子

    `shoes = {'name': 'Fancy Shoes', 'price': 14900}`

##TODO

顺便说一下,你有没有注意到我通过使用整数表示以分为单位的价格避免了找零时的四舍五入问题?这是一个好主意,
但是我不这么认为,现在,如果给予25%的折扣,我们期望的销售价格就会到$111.75

    `apply_discount(shoes, 0.25)
    >>> 11175`

一切正常.现在我们试试一些无效的折扣,比如200%的折扣,将会让我们倒付钱给消费者
    `>>> apply_discount(shoes, 2.0)`

    `Traceback (most recent call last):
    
    File "<input>", line 1, in <module>
    
    apply_discount(prod, 2.0)
    
    File "<input>", line 4, in apply_discount
    
    assert 0 <= price <= product['price']
    
    AssertionError`

如你所见,当我门尝试打一个无效的折扣的时候,我们的程序抛出了一个`AssertionError`.
之所以会这样是因为200%的折扣违反了我们在`apply_discount`函数中的断言条件
你还能看到异常错误栈指出了包含失败断言的哪一行代码,如果你(或者你们团队的其它开发者)在测试在线商店的时候遇到了这样的一个错误,
通过错误栈会很容易找到具体发生了什么

这会在很大成都上加快调试的速度,并且会让你的代码更易于维护.这就是断言的力量


## 为什么不直接使用一个常规的异常
你可能会疑惑为什么在上面的例子中我不直接使用`if`语句抛出一个异常.

正确使用断言可以通知开发者那些程序中不可恢复的错误.断言不是为了提示预期中的错误,
对于像文件没找到这种预期中的错误,用户可以采取纠正措施,或者直接重试

断言意味着程序的内部自检.断言会声明一些不可能发生的条件,如果这些条件没有被兜住,
意味着代码中存在bug

如果你的代码没有任何bug, 这些断言条件永远不会发生.但是一旦发生,程序就会崩溃,此时会抛出一个断言错误,
告诉你哪个"不可能"的条件被触发了.
这会让定位和修复bug变得简单.我喜欢任何让生活变得简单的事情--难道你不是吗?

到目前位置,牢记Python的断言是一个调试的辅助工具,不是一套处理运行时错误的机制.
使用断言是为了让开发者能够更快发现可能导致bug的根源.
如果程序没有bug,断言错误永远不应该被主动抛出

让我们看一下可以用断言做的其它事情,后面我将会列出2个实践中常见的陷阱


## Python的断言语法
在使用一个Python的特性之前,最好学习一下它是怎样实现的.我们快速看看Python文档中断言的语法

    `assert_stmt ::= "assert" expression1 ["," expression2]`

在这个例子中, expression1 是我们测试的条件, 可选的expression2 是一个断言失败后显示的错误信息.
在执行时,Python解释器吧每个断言转换成大致如下的语句:

    `if __debug__:
        if not expression1:
        raise AssertionError(expression2)`

这段代码里面有两件很有趣的事情:

在断言条件检查之前,对全局变量__debug__进行了额外的检查.__debug__是一个内建的bool值,
正常情况下这个值是true,如果需要优化,这个值是false
在后面常见陷阱部分,我们会对这个问题进行更深入的讨论

你还可以使用expression2传入一个用于在断言异常错误栈中显示的错误信息。
## TODO, 润色一下这里
这可以用于一些更深入的调试，比如下面的例子

    `if cond == 'x':
     ... do_x()
     elif cond == 'y':
     ... do_y()
     else:
     ... assert False, (
     ... 'This should never happen, but it does '
     ... 'occasionally. We are currently trying to '
     ... 'figure out why. Email dbader if you '
     ... 'encounter this in the wild. Thanks!')`
     
这确实是一种丑陋的写法，但在你遇到难以复现的bug的时候，这确实是一种有用的方法。


## Python中断言的常见陷阱

在继续之前，我还像指出两个和Python中断言相关的重要警告。
第一个和引入安全问题和bug有关，第二个和很容易写出无用断言的奇怪语法有关。

这听起来很恐怖，所以你最好至少遵守下面的两个警告

## 警告1：不要用断言进行数据验证

在使用Python断言时最大的警告：断言可以通过-0和--0命令行开关进行全局禁用，
CPython中的PYTHONOPTIMIZE环境变量也可以禁用断言

这会将所有的断言语句变成空操作：断言会在编译时被排除，并且永远不会被评估，这意味着没有任何断言会被执行

这是一个设计决策，在很多其它编程语言中也有类似的决策。
这种行为的副作用就是，使用断言对输入数据进行快速验证是极度危险的。

如果你的代码使用断言检查函数的参数是否包含一个"错误"的或者不在预期之内的值,
这可能会适得其反,导致一些bug或者安全漏洞.

让我们用一个简单例子说明这个问题. 假设你在使用Python搭建一个在线商城. 
在你应用的某个地方有一个函数根据用户的请求删除产品.

因为你刚刚学过断言,所以你很渴望在代码中使用断言,你写下了下面的代码.

    `def delete_product(prod_id, user):
        assert user.is_admin(), 'Must be admin'
        assert store.has_product(prod_id), 'Unknown product'
        store.get_product(prod_id).delete()`


仔细看看这个`delete_product`函数,如果断言被禁用,将会发生什么?

在这个三行代码的函数中,有两个很严重的问题,它们都是因为不正确地使用断言导致的.

- 使用断言检查管理员权限是很危险的. 如果在Python解释器中,断言被禁用,这将变成一个空操作.
所以任何人都可以删除产品.权限检查的代码甚至根本没有运行.这很有很能引入安全问题, 
  并且为攻击者摧毁或者严重损坏我们在线商城的数据打开大门.这不是一个好的用法.
  
- `has_product()`检查在断言禁用的时候会直接跳过.
  这意味着`get_product()`可以通过无效的产品id进行调用--这会导致更严重的bug.
  在最坏的情况下,这很可能是一个导致服务拒绝攻击的途径.
  比如,可能商城崩溃了,可能有人尝试删除了一个未知的商品,一个攻击者可能会通过无效的删除请求进行轰炸,进而导致服务中断.
  
我们怎么避免这些问题呢?答案就是永远不要使用断言进行数据验证.我们可以使用常规的if语句进行验证,在必要的时候抛出验证异常,比如:

    `def delete_product(product_id, user):
        if not user.is_admin():
        raise AuthError('Must be admin to delete')
        if not store.has_product(product_id):
        raise ValueError('Unknown product id')
        store.get_product(product_id).delete()`

这个更新后的例子还有一个好处: 
它现在抛出像ValueError或者AuthError(我们必须自己定义)这类语义上正确地异常,
而不是抛出一个不明确的断言异常.


## 警告2: 永不失败的断言

偶然写出永远为真的Python断言是一件相当容易的事情.我在过去就尝到过这样的苦果.
## TODO 补充一句

当你将元祖做为第一个函数传给断言的时候,断言总是为真,从不失败.
下面的这个例子中断言永远不会失败.

    `assert(1 == 2, 'This should fail')`

这和Python中不为空的元祖总是为真有关.
如果你传一个元祖给一个断言,会导致断言条件永远是真--进而导致上面的断言语无效,
因为断言语句永远不会失败,永远不会出发一个异常.

相对来说很容易因为直觉行为写出这种多行的糟糕断言。
比如，我很快乐的在我的一个测试套件中写了一堆无用的测试用例，这些用例给人以一种错误的安全感。
想象一下在你的一个单元测试中有如下的断言。

    `assert (
     counter == 10,
     'It should have counted all the items'
     )`
     
在第一次检测的时候，这个测试案例看起来没有任何问题。
然而它永远不会捕获错误的结果：无论变量counter的值为何，断言总是为真。
为什么会这样呢？因为它在对一个值为真的元组进行断言。

就像我说过的，这种做法很容易砸到自己的脚。一个很好的防止这种奇怪预发引起麻烦的对策是使用[code linter](https://dbader.org/blog/catching-bogus-python-asserts)
Python3的新版本会对这种模糊的断言给出警告。

顺便说一句，这就是为什么你应该始终对单元测试用例进行快速烟雾测试的原因。
确保它们确实可以失败然后继续写下一个。


## Python断言--总结

除了这些经过，我坚信Python的断言是一个没有被Python开发者充分使用的调试工具。

懂得断言怎么工作，在什么时候使用断言可以帮助你写出更容易维护的和更容易调试的代码。

这是一项很棒的学习技能，它可让你的Python知识更进一步，使你成为更全面的Pythonista。
我知道它节省了我数小时的调试工作。


## 重点
- Python的assert语句是一种调试辅助工具，可以使用内部自检的方式测试一个条件。
- 断言仅应用于帮助开发人员识别错误。它们不是用于处理运行时错误的机制。
- 可以通过解释器设置在全局禁用断言。


## 2.2 逗号放置  #TODO: 润色

当你在Python中的列表，字典或集合中增删元素的时候，有一个有用的建议：以逗号作为所有行的结尾。






