## 3.1 Python的函数是一类对象

Python的函数是一类对象。
你可以将它们分配给变量，将它们存储在数据结构中，将它们作为参数传递给其他函数，甚至将它们作为其他函数的返回值。

理解这些概念将使你在深入理解Python中lambda和装饰器这类高级功能时更轻松。
它还能使你接触函数式编程的技术。

在接下来的几页中，我将指导你完成许多示例以帮助你加深理解。
这些例子一环扣一环，因此你可能需要按顺序阅读它们，甚至需要尝试其中的一些例子。

消化我们将在这里讨论的概念可能会花费比你预期更长的时间。
不用担心，那完全正常。我经历过，你可能会觉得自己把头撞在墙上，
然后突然之间事情会在你准备好后，回到适当的位置。

在本章中，我将使用此yell函数进行演示。这是一个简单的示例：

    `def yell(text):
    return text.upper() + '!'
    >>> yell('hello')
    'HELLO!'`

## 函数是对象

Python程序中的所有数据均由对象或表示对象之间的关系代表。
诸如字符串，列表，模块和函数都是对象。 在Python中，函数没有什么特别之处，它们也只是对象。

由于yell函数是Python中的对象，因此你可以像其他任何对象一样，将其赋值给另一个变量：

    `>>> bark = yell`

该行不会调用该函数。它获取yell引用的函数对象，并创建指向它的第二个名称bark。
你现在也可以通过调用bark执行相同的函数对象：

    `>>> bark('woof')
    'WOOF!'`

函数对象及其名称是两个单独的概念。
你可以删除函数的原始名称yell，另一个名称bark仍指向原来的函数，你仍然可以通过bark调用函数：

    `>>> del yell
    >>> yell('hello?')
    NameError: "name 'yell' is not defined"
    >>> bark('hey')
    'HEY!'`

顺便说一句，为了调试方便，Python在创建函数时，为每个函数添加了一个字符串标识符。
你可以通过__name__属性访问此标识符：

    `>>> bark.__name__
    'yell'`

现在，虽然函数的__name__属性仍然是yell，但这并不影响从代码访问函数对象。
名称标识符仅仅用于辅助调试。指向函数的变量和函数本身实际上是两个独立的点。

## 函数可以被保存在数据结构中

由于函数是一等公民，因此你可以像处理其他对象一样，将其存储在数据结构中。 
例如，你可以将函数添加到列表中：

    `>>> funcs = [bark, str.lower, str.capitalize]
    >>> funcs
    [<function yell at 0x10ff96510>,
    <method 'lower' of 'str' objects>,
    <method 'capitalize' of 'str' objects>]
    `

访问存储在列表中的函数对象和访问任何其他类型的对象没有区别：

    `>>> for f in funcs:
    ... print(f, f('hey there'))
    <function yell at 0x10ff96510> 'HEY THERE!'
    <method 'lower' of 'str' objects> 'hey there'
    <method 'capitalize' of 'str' objects> 'Hey there'`

您甚至可以调用存储在列表中的函数对象，而无需将其先赋值给一个变量。
您可以进行查找，然后立即在单个表达式中调用返回的函数对象：

    `>>> funcs[0]('heyho')
    'HEYHO!'`

## 函数可以当做参数传给其它函数

因为函数是对象，所以您可以将它们作为参数传递给其他函数。
这个greet函数用于格式化问候字符串，在期间会调用传递给它的函数对象，然后打印它：

    `def greet(func):
        greeting = func('Hi, I am a Python program')
        print(greeting)`

您可以通过传递不同的函数来影响产生的结果。 如果您传入bark函数，结果会像下面这样：

    `>>> greet(bark)
    'HI, I AM A PYTHON PROGRAM!'`

当然，您也可以定义一个新函数来生成不同的问候语。
比如，如果您不希望您的Python程序听起来听起来像擎天柱，下面的whisper函数可能会更好：

    `def whisper(text):
        return text.lower() + '...'
    >>> greet(whisper)
    'hi, i am a python program...'`

将函数对象作为参数传递给其他函数是很强大的功能。
它可以让您在程序中抽象并绕过其中的行为。
在这里示例中，greet函数保持不变，但您可以通过传递不同的问候行为来影响其输出。

可以接受其他函数作为参数的函数也称为高阶函数。
它们是函数式编程的必要条件。

Python中高阶函数的经典示例是内置的map函数。
其参数是一个函数对象和一个可迭代对象，然后随着迭代进行，它在每个可迭代的元素上调用函数、产生结果。

您也可以通过将bark函数进行mapping一次性格式化一系列问候语：

    `>>> list(map(bark, ['hello', 'hey', 'hi']))
    ['HELLO!', 'HEY!', 'HI!']`

如您所见，map遍历了整个列表，并将bark函数应用于每个元素。
结果，现在我们有了一个新列表。

## 函数可以嵌套

也许会令人惊讶，Python允许在函数内部定义函数。
这些通常称为嵌套函数或内部函数。这是一个例子：

    `def speak(text):
        def whisper(t):
            return t.lower() + '...'
        return whisper(text)
    >>> speak('Hello, World')
    'hello, world...'`

现在，这是怎么回事？ 每次调用speak函数时，它都会定义一个新的内部函数whisper，然后立即调用它。
我在这里理解得有点慢，但是总的来说，这仍然是相对简单的东西。

speak函数外部不存在whisper：

    `>>> whisper('Yo')
    NameError:
    "name 'whisper' is not defined"
    >>> speak.whisper
    AttributeError:
    "'function' object has no attribute 'whisper'"`

但是，如果您真的想从speak函数外访问该嵌套的whisper函数，该怎么办？
好吧，函数就是对象，您可以返回内部函数给父函数的调用者。

例如，这是一个定义了两个内部函数的函数。
根据传递给外层函数的参数，它选择并返回其中一个内部函数给调用者：

    `def get_speak_func(volume):
        def whisper(text):
            return text.lower() + '...'
    
        def yell(text):
            return text.upper() + '!'
    
        if volume > 0.5:
            return yell
        else:
            return whisper`

请注意，get_speak_func实际上并未调用其内部的任何函——它仅根据volume参数选择了适当的内部函数并将其返回：

    `>>> get_speak_func(0.3)
    <function get_speak_func.<locals>.whisper at 0x10ae18>
    >>> get_speak_func(0.7)
    <function get_speak_func.<locals>.yell at 0x1008c8>`

当然，您可以直接调用返回的函数，或者首先将其分配给变量然后再进行调用：

    `>>> speak_func = get_speak_func(0.7)
    >>> speak_func('Hello')
    'HELLO!'`

先静下心来想一想...
这意味着函数不仅可以通过参数接受行为，还可以可以返回行为。多么酷啊！

您知道吗，到这里后，事情开始有些混乱了。
我要在继续写作之前先去喝杯咖啡休息一下（我建议你也来一杯）

## 函数可以捕获局部状态

您刚刚看到了函数如何包含内部函数，并且函数还可以从父函数返回这些内部函数。

现在最好系上安全带，因为后面会有点疯狂。我们将进入更深层次的函数编程领域。（你有喝咖啡休息，对吧？）

函数不仅可以返回其他函数，而且这些内部函数也可以捕获并携带某些父函数的状态。
好吧，那是什么意思呢？

我重写一下之前的get_speak_func示例来说明这一点。
新版本带有一个“volume”和一个“text”参数，以使返回的函数可立即调用：

    `def get_speak_func(text, volume):
        def whisper():
            return text.lower() + '...'

        def yell():
            return text.upper() + '!'

        if volume > 0.5:
            return yell
        else:
            return whisper

    >>> get_speak_func('Hello, World', 0.7)()
    'HELLO, WORLD!'`

现在，仔细看看内部函数whisper和yell。
注意他们为何不再需要text参数？但是他们仍然可以访问父函数中定义的text参数。
实际上，他们似乎捕获并“记住”了这个参数的值。

执行此操作的函数称为词法闭包（简称闭包）。
即使程执行已经不在该范围内，闭包也会记住其封闭词法中的值。

实际上，这意味着函数不仅可以返回行为它们也可以预先配置这些行为。这是来说明这个想法的另一个简单例子：

    `def make_adder(n):
        def add(x):
            return x + n
        return add
    >>> plus_3 = make_adder(3)
    >>> plus_5 = make_adder(5)
    >>> plus_3(4)
    7
    >>> plus_5(4)
    9`

在此示例中，make_adder用作创建和配置“adder”函数的工厂。
注意观察adder函数仍然可以访问make_adder函数的参数n（封闭范围）。

## 对象可以表现得像函数

尽管所有函数都是Python中的对象，但反之并不成立。
对象不是函数，但是可以将它们设为可调用的，这允许您在许多情况下将它们视为函数。

如果一个对象是可调用的，则意味着您可以使用圆括号函数调用语法，甚至传递函数调用参数。
所有这些都由__call__方法实现。这是定义可调用对象的示例：

    `class Adder:
    def __init__(self, n):
        self.n = n
    def __call__(self, x):
        return self.n + x
    >>> plus_3 = Adder(3)
    >>> plus_3(4)
    7`

实际上，“调用”对象会尝试执行对象的__call__方法。

当然，并非所有对象都是可调用的。这就是为什么会有内置的用于检查对象是否看起来可调用的的callable函数：

    `>>> callable(plus_3)
    True
    >>> callable(yell)
    True
    >>> callable('hello')
    False`

## 重点

Python中包括函数在内的所有内容都是一个对象。
你可以将它们赋值给变量，将它们存储在数据结构中，将它们传递或返回给其他函数（或从其他函数返回）。
  - 一类的函数使您可以抽象和传递行为。  #　TODO: 润色 
  - 函数可以嵌套，并且可以捕获并携带一些
  - 父函数的状态。这个功能被称为闭包。
  - 可以使对象像函数一样可调用。在许多情况下，这使您可以像对待函数一样对待他们。

# 3.2 lambda是但表达式函数

Python中的lambda关键字提供了声明小型匿名函数的快捷方式。
Lambda函数的行为类似于用def关键字声明的常规函数。需要函数对象时，可以使用lambda函数。

例如，这是您定义的用于执行加法简单lambda函数：

    `>>> add = lambda x，y：x + y
    >>>添加（5，3）
    8`
    





