## 3.1 Python的函数是一类对象

Python的函数是一类对象。
你可以将它们分配给变量，将它们存储在数据结构中，将它们作为参数传递给其他函数，甚至将它们作为其他函数的返回值。

理解这些概念将使你在深入理解Python中lambda和装饰器这类高级功能时更轻松。
它还能使你接触函数式编程的技术。

在接下来的几页中，我将指导你完成许多示例以帮助你加深理解。
这些例子一环扣一环，因此你可能需要按顺序阅读它们，甚至需要尝试其中的一些例子。

消化我们将在这里讨论的概念可能会花费比你预期更长的时间。
不用担心，那完全正常。我经历过，你可能会觉得自己把头撞在墙上，
然后突然之间事情会在你准备好后，回到适当的位置。

在本章中，我将使用此yell函数进行演示。这是一个简单的示例：

    `def yell(text):
    return text.upper() + '!'
    >>> yell('hello')
    'HELLO!'`

## 函数是对象

Python程序中的所有数据均由对象或表示对象之间的关系代表。
诸如字符串，列表，模块和函数都是对象。 在Python中，函数没有什么特别之处，它们也只是对象。

由于yell函数是Python中的对象，因此你可以像其他任何对象一样，将其赋值给另一个变量：

    `>>> bark = yell`

该行不会调用该函数。它获取yell引用的函数对象，并创建指向它的第二个名称bark。
你现在也可以通过调用bark执行相同的函数对象：

    `>>> bark('woof')
    'WOOF!'`

函数对象及其名称是两个单独的概念。
你可以删除函数的原始名称yell，另一个名称bark仍指向原来的函数，你仍然可以通过bark调用函数：

    `>>> del yell
    >>> yell('hello?')
    NameError: "name 'yell' is not defined"
    >>> bark('hey')
    'HEY!'`

顺便说一句，为了调试方便，Python在创建函数时，为每个函数添加了一个字符串标识符。
你可以通过__name__属性访问此标识符：

    `>>> bark.__name__
    'yell'`

现在，虽然函数的__name__属性仍然是yell，但这并不影响从代码访问函数对象。
名称标识符仅仅用于辅助调试。指向函数的变量和函数本身实际上是两个独立的点。

## 函数可以被保存在数据结构中

由于函数是一等公民，因此你可以像处理其他对象一样，将其存储在数据结构中。 
例如，你可以将函数添加到列表中：

    `>>> funcs = [bark, str.lower, str.capitalize]
    >>> funcs
    [<function yell at 0x10ff96510>,
    <method 'lower' of 'str' objects>,
    <method 'capitalize' of 'str' objects>]
    `

访问存储在列表中的函数对象和访问任何其他类型的对象没有区别：

    `>>> for f in funcs:
    ... print(f, f('hey there'))
    <function yell at 0x10ff96510> 'HEY THERE!'
    <method 'lower' of 'str' objects> 'hey there'
    <method 'capitalize' of 'str' objects> 'Hey there'`

你甚至可以调用存储在列表中的函数对象，而无需将其先赋值给一个变量。
你可以进行查找，然后立即在单个表达式中调用返回的函数对象：

    `>>> funcs[0]('heyho')
    'HEYHO!'`

## 函数可以当做参数传给其它函数

因为函数是对象，所以你可以将它们作为参数传递给其他函数。
这个greet函数用于格式化问候字符串，在期间会调用传递给它的函数对象，然后打印它：

    `def greet(func):
        greeting = func('Hi, I am a Python program')
        print(greeting)`

你可以通过传递不同的函数来影响产生的结果。 如果你传入bark函数，结果会像下面这样：

    `>>> greet(bark)
    'HI, I AM A PYTHON PROGRAM!'`

当然，你也可以定义一个新函数来生成不同的问候语。
比如，如果你不希望你的Python程序听起来听起来像擎天柱，下面的whisper函数可能会更好：

    `def whisper(text):
        return text.lower() + '...'
    >>> greet(whisper)
    'hi, i am a python program...'`

将函数对象作为参数传递给其他函数是很强大的功能。
它可以让你在程序中抽象并绕过其中的行为。
在这里示例中，greet函数保持不变，但你可以通过传递不同的问候行为来影响其输出。

可以接受其他函数作为参数的函数也称为高阶函数。
它们是函数式编程的必要条件。

Python中高阶函数的经典示例是内置的map函数。
其参数是一个函数对象和一个可迭代对象，然后随着迭代进行，它在每个可迭代的元素上调用函数、产生结果。

你也可以通过将bark函数进行mapping一次性格式化一系列问候语：

    `>>> list(map(bark, ['hello', 'hey', 'hi']))
    ['HELLO!', 'HEY!', 'HI!']`

如你所见，map遍历了整个列表，并将bark函数应用于每个元素。
结果，现在我们有了一个新列表。

## 函数可以嵌套

也许会令人惊讶，Python允许在函数内部定义函数。
这些通常称为嵌套函数或内部函数。这是一个例子：

    `def speak(text):
        def whisper(t):
            return t.lower() + '...'
        return whisper(text)
    >>> speak('Hello, World')
    'hello, world...'`

现在，这是怎么回事？ 每次调用speak函数时，它都会定义一个新的内部函数whisper，然后立即调用它。
我在这里理解得有点慢，但是总的来说，这仍然是相对简单的东西。

speak函数外部不存在whisper：

    `>>> whisper('Yo')
    NameError:
    "name 'whisper' is not defined"
    >>> speak.whisper
    AttributeError:
    "'function' object has no attribute 'whisper'"`

但是，如果你真的想从speak函数外访问该嵌套的whisper函数，该怎么办？
好吧，函数就是对象，你可以返回内部函数给父函数的调用者。

例如，这是一个定义了两个内部函数的函数。
根据传递给外层函数的参数，它选择并返回其中一个内部函数给调用者：

    `def get_speak_func(volume):
        def whisper(text):
            return text.lower() + '...'
    
        def yell(text):
            return text.upper() + '!'
    
        if volume > 0.5:
            return yell
        else:
            return whisper`

请注意，get_speak_func实际上并未调用其内部的任何函——它仅根据volume参数选择了适当的内部函数并将其返回：

    `>>> get_speak_func(0.3)
    <function get_speak_func.<locals>.whisper at 0x10ae18>
    >>> get_speak_func(0.7)
    <function get_speak_func.<locals>.yell at 0x1008c8>`

当然，你可以直接调用返回的函数，或者首先将其分配给变量然后再进行调用：

    `>>> speak_func = get_speak_func(0.7)
    >>> speak_func('Hello')
    'HELLO!'`

先静下心来想一想...
这意味着函数不仅可以通过参数接受行为，还可以可以返回行为。多么酷啊！

你知道吗，到这里后，事情开始有些混乱了。
我要在继续写作之前先去喝杯咖啡休息一下（我建议你也来一杯）

## 函数可以捕获局部状态

你刚刚看到了函数如何包含内部函数，并且函数还可以从父函数返回这些内部函数。

现在最好系上安全带，因为后面会有点疯狂。我们将进入更深层次的函数编程领域。（你有喝咖啡休息，对吧？）

函数不仅可以返回其他函数，而且这些内部函数也可以捕获并携带某些父函数的状态。
好吧，那是什么意思呢？

我重写一下之前的get_speak_func示例来说明这一点。
新版本带有一个“volume”和一个“text”参数，以使返回的函数可立即调用：

    `def get_speak_func(text, volume):
        def whisper():
            return text.lower() + '...'

        def yell():
            return text.upper() + '!'

        if volume > 0.5:
            return yell
        else:
            return whisper

    >>> get_speak_func('Hello, World', 0.7)()
    'HELLO, WORLD!'`

现在，仔细看看内部函数whisper和yell。
注意他们为何不再需要text参数？但是他们仍然可以访问父函数中定义的text参数。
实际上，他们似乎捕获并“记住”了这个参数的值。

执行此操作的函数称为词法闭包（简称闭包）。
即使程执行已经不在该范围内，闭包也会记住其封闭词法中的值。

实际上，这意味着函数不仅可以返回行为它们也可以预先配置这些行为。这是来说明这个想法的另一个简单例子：

    `def make_adder(n):
        def add(x):
            return x + n
        return add
    >>> plus_3 = make_adder(3)
    >>> plus_5 = make_adder(5)
    >>> plus_3(4)
    7
    >>> plus_5(4)
    9`

在此示例中，make_adder用作创建和配置“adder”函数的工厂。
注意观察adder函数仍然可以访问make_adder函数的参数n（封闭范围）。

## 对象可以表现得像函数

尽管所有函数都是Python中的对象，但反之并不成立。
对象不是函数，但是可以将它们设为可调用的，这允许你在许多情况下将它们视为函数。

如果一个对象是可调用的，则意味着你可以使用圆括号函数调用语法，甚至传递函数调用参数。
所有这些都由__call__方法实现。这是定义可调用对象的示例：

    `class Adder:
    def __init__(self, n):
        self.n = n
    def __call__(self, x):
        return self.n + x
    >>> plus_3 = Adder(3)
    >>> plus_3(4)
    7`

实际上，“调用”对象会尝试执行对象的__call__方法。

当然，并非所有对象都是可调用的。这就是为什么会有内置的用于检查对象是否看起来可调用的的callable函数：

    `>>> callable(plus_3)
    True
    >>> callable(yell)
    True
    >>> callable('hello')
    False`

## 重点

Python中包括函数在内的所有内容都是一个对象。
你可以将它们赋值给变量，将它们存储在数据结构中，将它们传递或返回给其他函数（或从其他函数返回）。
  - 一类的函数使你可以抽象和传递行为。  #　TODO: 润色 
  - 函数可以嵌套，并且可以捕获并携带一些
  - 父函数的状态。这个功能被称为闭包。
  - 可以使对象像函数一样可调用。在许多情况下，这使你可以像对待函数一样对待他们。

# 3.2 lambda是单表达式函数

Python中的lambda关键字提供了声明小型匿名函数的快捷方式。
Lambda函数的行为类似于用def关键字声明的常规函数。需要函数对象时，可以使用lambda函数。

例如，这是你定义的用于执行加法简单lambda函数：

    `>>> add = lambda x，y：x + y
    >>> add(5, 3)
    8`

你可以用def关键字声明相同的add函数，但它会更加冗长：
    
    `>>> def add(x, y):
         return x + y
    >>> add(5, 3)
    8`

现在你可能想知道，lambda有什么特别的地方？
如果它们只是用def声明函数的简明版本，有什么大不了的？

请看以下示例，在看的时候将“函数表达式”这个词记在脑海中：

    `>>> (lambda x, y: x + y)(5, 3)
    8`

好的，这是怎么回事？我只是使用lambda定义了一个add函数，然后使用参数5和3立即调用这个函数。

从概念上讲，lambda表达式lambda x, y: x + y与使用def声明的函数没有区别，它只是写在一行中。
主要区别在于在使用之前我不必分配一个名字给匿名函数对象。
我只是在lambda表达式中描述我的计算逻辑，然后像调用常规函数一样立即调用lambda表达式。

在继续之前，为了真正理解其含义，你可能需要把玩一下之前的代码。
我仍然记得我花了一段时间来理清这些东西。
所以不用担心在一个解释器的会话窗口上多花了几分钟，这是值得的。

lambda函数和常规函数之间还有另一个语法差异。
Lambda函数仅限于一个表达式。
这意味着lambda函数不能使用语句或注释——甚至没有return语句。

那么如何从lambda返回值？执行lambda函数时会计算其表达式的值，然后自动返回计算结果，因此总会有一个隐式的返回值。
这就是为什么有些人将lambda称为单个表达式函数。

## 你可以使用的lambda表达式

什么时候应该在代码中使用lambda函数？
从技术上讲，在任何你期望提供一个函数对象的时候，都可以使用lambda表达式。
而且因为lambda是匿名的，你甚至都不需要首先为其分配一个名称。

这提供了一个方便且简洁的快捷方式来定义Python中的函数。
我最常使用lambda的场景是书写简洁的key函数，用于通过提供key函数对可迭代对象进行排序：

    `>>> tuples = [(1, 'd'), (2, 'b'), (4, 'a'), (3, 'c')]
    >>> sorted(tuples, key=lambda x: x[1])
    [(4, 'a'), (2, 'b'), (3, 'c'), (1, 'd')]`

在上面的示例中，我们按第二个值对元组列表进行排序。
在这种情况下，lambda函数提供了一种快速的方法修改排序顺序。
这是你可以把玩的另一个排序示例：

    `>>> sorted(range(-5, 6), key=lambda x: x * x)
    [0, -1, 1, -2, 2, -3, 3, -4, 4, -5, 5]`

我向你展示的两个示例使用Python内置的operator.itemgetter()和abs()函数都有更简洁的实现。
但我希望你能看到使用lambda会给你带来更大的灵活性。
要按一个任意计算的key对序列进行排序？没问题，现在你知道该怎么做了。

这是关于lambda的另一件有趣的事情：就像常规的嵌套函数一样，lambda还可作为词法闭包。

什么是词法闭包？它只是一个函数的奇特名称，表示即使程序已经不再在该范围内，但是还是会记住来自封闭词法范围的值。
这是一个说明这个想法的例子：

    `>>> def make_adder(n):
         return lambda x: x + n

    >>> plus_3 = make_adder(3)
    >>> plus_5 = make_adder(5)
    >>> plus_3(4)
    7
    >>> plus_5(4)
    9`

在上面的示例中，即使n是在make_adder函数中定义的（闭包范围），x + n lambda表达式仍可以访问n的值。

有时，使用Lambda函数而不是用def关键字声明的嵌套函数可以更清楚地表达程序员的意图。
但是，老实说，这并不常见——至少这不是我所喜欢的代码风格。
所以我们再谈一点关于这个话题的信息。

##　或许你不应该...

一方面，我希望本章能使你对探索Python的lambda函数感兴趣。
另一方面，我觉得是时候提出另一个警告了：应谨慎使用Lambda函数。

我知道我已经使用lambda编写了相当一部分“很酷”的代码，但实际上这对我和我的同事来说是个负担。
如果你倾向于使用lambda，花几秒钟（或几分钟）思考一下，这是否是实现这一目标的最简洁，维护型最好的方法。

例如，做下面这样的事情来节省两行代码是愚蠢的。
当然，从技术上讲，它是可行的，并且有点炫技。
但这也让下一个必须在一个很紧凑的期限内修正错误的同事感到困惑：

    `# Harmful:
    >>> class Car:
    ... rev = lambda self: print('Wroom!')
    ... crash = lambda self: print('Boom!')
    >>> my_car = Car()
    >>> my_car.crash()
    'Boom!'`

我对使用lambda的复杂map()或filter()函数有类似的感觉。
通常，使用列表表达式或生成器表达式会更简洁：

    `# Harmful:
    >>> list(filter(lambda x: x % 2 == 0, range(16)))
    [0, 2, 4, 6, 8, 10, 12, 14]
    # Better:
    >>> [x for x in range(16) if x % 2 == 0]
    [0, 2, 4, 6, 8, 10, 12, 14]`

如果你发现自己在使用lambda表达式做很复杂的事情，请考虑定义一个具有合适名称的独立函数来实现。

从长远来看，节省几行代码无关紧要，但是你的同事（以及未来的你）会喜欢清晰易读的代码而不是一些奇技淫巧。

## 重点

 - Lambda函数是单表达式函数，不必绑定到名称（匿名）。
 - Lambda函数不能使用常规的Python语句，并且总是包含隐式return语句。
 - 始终问自己：使用常规函数或列表解析是否会让代码更清晰？

## 3.3 装饰器的威力

Python的装饰器可让你扩展和修改其核心可调用对象（函数，方法和类）的行为，而无需永久修改可调用对象本身。

任何可以附加到现有类或函数的足够通用的功能非常适用于装饰。
这包括以下内容：

 - 日志
 - 实施访问控制和身份验证
 - 说明和计时
 - 限速
 - 缓存等

为什么要掌握Python中的装饰器呢？
毕竟，我刚才提到的内容听起来很抽象，可能很难理解装饰器如何让Python程序员在日常工作中受益。
让我通过给你一个真实的例子来设法使这个问题更加清楚：

想象一下，你的报表生成程序有30个涉及具体业务逻辑的函数。
一个多雨的星期一早上，你的老板走到你办公桌前说：“星期一快乐！记得那些TPS报告吗？
我需要你将输入/输出日志记录添加到报告生成工具。XYZ公司需要用它进行审计。
哦，我告诉他们我们可以在星期三之前完成。

根据你是否深刻理解Python装饰器，这个需求可能会让你压力山大也可能让你平静如常。

如果没有装饰器，你可能会在接下来的三天时间里手动修改这30个功能中的每一个，并添加一堆杂乱无章的日志调用。
好玩的时间，对不对？

但是，如果你知道装饰师，你就可以冷静地微笑着对老板说：“别担心吉姆，我会在今天下午2点之前完成。”

此后，你将编写一个通用的@audit_log装饰器（仅约10行），然后将其快速粘贴到每个函数定义代码的前面。
然后提交代码并拿起另一杯咖啡...

我在这里有点戏剧化。装饰器就是可以这么强大。
我要说的是，对任何认真的Python程序员来说，了解装饰师都是一个里程碑。
他们需要扎实地掌握语言中的几个高级概念。

我相信，在Python中，理解装饰器的收益是巨大的

当然，开始的时候装饰器确实有点难以理解，但是它们是非常有用的功能，你在第三方框架和Python标准库中会经常遇到装饰器。
解释装饰器也是任何Python教程成败的关键。我会尽力在这里向你介绍他们。

在开始学习之前，现在是重新复习一下Python一类函数属性的绝佳时机。
本书中有一章介绍了这些内容，我鼓励你花几分钟时间进行复习。
了解装饰器需要知道的最重要的“一类函数”的要点是：

 - 函数是对象，可以将它们分配给变量和传递给其他函数并从其他函数返回
 - 可以在其他函数中定义函数，并且子函数可以捕获父函数的局部状态（词法闭包）

好了，你准备好了吗？让我们开始吧。

## Python装饰器基础

现在，装饰器到底是什么？他们“装饰”或“包裹”另一个函数，并让你在被装饰函数运行之前和之后执行代码。

装饰器允许你定义可重复使用的代码块，这些代码块可以更改或扩展其他函数的行为。
而且，装饰器让你在不修改被装饰函数本身的前提下执行此操作。该函数的行为仅在装饰后才会改变。

一个简单的装饰器的实现会是什么样子？简单来说，装饰器是一个可调用对象，它以可调用对象为输入，返回另一个可调用对象。

以下函数就是这样，这可能是你可以写出的最简单的装饰器：

    `def null_decorator(func):
        return func`

如你所见，`null_decorator`是可调用的（它是一个函数），它接受另一个可调用对象作为其输入，并原样返回相同的可调用对象。

让我们用它来装饰（或包装）另一个函数：

    `def greet():
        return 'Hello!'

    greet = null_decorator(greet)

    >>> greet()
    'Hello!`

在此示例中，我定义了一个greet函数，然后通过运行null_decorator函数来装饰它。
我知道这看起来不太有用。我的意思是，我们故意将null_decorator装饰器设计为无用的，对吗？
但是稍后，这个例子将充分说明Python装饰器语法的工作原理。

你可以使用Python的@语法更方便地装饰函数，而不必在greet上显式调用null_decorator函数然后重新赋值greet变量。

    `@null_decorator
    def greet():
        return 'Hello!'

    >>> greet()
    'Hello!'`

在函数定义的前面放置一个@null_decorator行和先定义函数然后调用null_decorator函数没有区别。
@语法只是一个语法糖，是这种常用模式的一个捷径。

请注意，使用@语法会在函数定义时立即装饰函数。
这使得在没有使用黑魔法的情况下很难访问未经装饰的原始函数。
因此，为了保持调用未修饰函数的功能，你可能会选择手动执行某些函数装饰器。

## 装饰器可以修改行为

现在，你对装饰器语法有了更多的了解，让我们编写另一个装饰器，该装饰器实际上会执行某些操作并修改被装饰函数的行为。

这是一个稍微复杂一点的装饰器，它可以将被装饰函数的输出转换为大写：

    `def uppercase(func):
        def wrapper():
            original_result = func()
            modified_result = original_result.upper()
            return modified_result
        return wrapper`

这个`uppercase`装饰器不像`null_decorator`装饰器那样简单地返回输入函数，
而是动态定义了一个新函数（闭包）并使用它来包装输入函数，以修改其调用时的行为。

`wrapper`闭包可以访问未修饰的输入函数，并且在调用输入函数之前和之后可以自由执行其他代码。（从技术上讲，它甚至不需要调用输入函数）

请注意，到目前为止，被装饰函数是从未执行过的。
实际上，这时调用输入函数不会有任何意义——你希望装饰器在最终被调用时能够修改其输入函数的行为。

你可能想花一两分钟消化一下这些知识点。
我知道这些东西看起来有多复杂，但我们终会将它们整理在一起的，我承诺。

是时候看看`uppercase`装饰器的作用了。如果用它装饰开始的greet函数会发生什么？

    `@uppercase
    def greet():
        return 'Hello!'

    >>> greet()
    'HELLO!'`

我希望这是你期望的结果，让我们仔细看看刚刚发生了什么。
与`null_decorator`不同，我们的`uppercase`装饰器在装饰函数时返回了一个不同的函数对象：

    `>>> greet
    <function greet at 0x10e9f0950>

    >>> null_decorator(greet)
    <function greet at 0x10e9f0950>

    >>> uppercase(greet)
    <function uppercase.<locals>.wrapper at 0x76da02f28>`

如你先前所见，它需要这样做才能修改被装饰函数在最终被调用时的行为。
`uppercase`装饰器本身就是一个函数。
影响它装饰的输入函数“未来行为”的唯一方法是使用一个闭包替换（或包装）输入函数。

这就是为什么`uppercase`装饰器需定义并返回另一个函数（闭包）的原因，
这个函数在后面可以被调用，它会运行原始的输入函数，并修改它的结果。

装饰器可以修改可调用对象的行为，因此你不必直接修改原始对象。
装饰时，原始可调用对象没有被永久修改——仅其行为发生了变化。

这样一来，你就可以在现有的函数和类上添加可复用的代码块，比如日志记录和其他工具。
装饰器具有如此强大的功能，所以在标准库和第三方程序包中装饰器被大量使用。

## 快速中场休息

顺便说一句，如果你感觉需要喝杯咖啡休息一下或走一走，这是完全正常的。
在我看来，闭包和装饰器是Python中最难理解的一些概念。




