## 3.1 Python的函数是一类对象

Python的函数是一类对象。
你可以将它们分配给变量，将它们存储在数据结构中，将它们作为参数传递给其他函数，甚至将它们作为其他函数的返回值。

理解这些概念将使你在深入理解Python中lambda和装饰器这类高级功能时更轻松。
它还能使你接触函数式编程的技术。

在接下来的几页中，我将指导你完成许多示例以帮助你加深理解。
这些例子一环扣一环，因此你可能需要按顺序阅读它们，甚至需要尝试其中的一些例子。

消化我们将在这里讨论的概念可能会花费比你预期更长的时间。
不用担心，那完全正常。我经历过，你可能会觉得自己把头撞在墙上，
然后突然之间事情会在你准备好后，回到适当的位置。

在本章中，我将使用此yell函数进行演示。这是一个简单的示例：

    `def yell(text):
    return text.upper() + '!'
    >>> yell('hello')
    'HELLO!'`

## 函数是对象

Python程序中的所有数据均由对象或表示对象之间的关系代表。
诸如字符串，列表，模块和函数都是对象。 在Python中，函数没有什么特别之处，它们也只是对象。

由于yell函数是Python中的对象，因此你可以像其他任何对象一样，将其赋值给另一个变量：

    `>>> bark = yell`

该行不会调用该函数。它获取yell引用的函数对象，并创建指向它的第二个名称bark。
你现在也可以通过调用bark执行相同的函数对象：

    `>>> bark('woof')
    'WOOF!'`

函数对象及其名称是两个单独的概念。
你可以删除函数的原始名称yell，另一个名称bark仍指向原来的函数，你仍然可以通过bark调用函数：

    `>>> del yell
    >>> yell('hello?')
    NameError: "name 'yell' is not defined"
    >>> bark('hey')
    'HEY!'`

顺便说一句，为了调试方便，Python在创建函数时，为每个函数添加了一个字符串标识符。
你可以通过__name__属性访问此标识符：

    `>>> bark.__name__
    'yell'`

现在，虽然函数的__name__属性仍然是yell，但这并不影响从代码访问函数对象。
名称标识符仅仅用于辅助调试。指向函数的变量和函数本身实际上是两个独立的点。

## 函数可以被保存在数据结构中

由于函数是一等公民，因此你可以像处理其他对象一样，将其存储在数据结构中。 
例如，你可以将函数添加到列表中：

    `>>> funcs = [bark, str.lower, str.capitalize]
    >>> funcs
    [<function yell at 0x10ff96510>,
    <method 'lower' of 'str' objects>,
    <method 'capitalize' of 'str' objects>]
    `

访问存储在列表中的函数对象和访问任何其他类型的对象没有区别：

    `>>> for f in funcs:
    ... print(f, f('hey there'))
    <function yell at 0x10ff96510> 'HEY THERE!'
    <method 'lower' of 'str' objects> 'hey there'
    <method 'capitalize' of 'str' objects> 'Hey there'`

你甚至可以调用存储在列表中的函数对象，而无需将其先赋值给一个变量。
你可以进行查找，然后立即在单个表达式中调用返回的函数对象：

    `>>> funcs[0]('heyho')
    'HEYHO!'`

## 函数可以当做参数传给其它函数

因为函数是对象，所以你可以将它们作为参数传递给其他函数。
这个greet函数用于格式化问候字符串，在期间会调用传递给它的函数对象，然后打印它：

    `def greet(func):
        greeting = func('Hi, I am a Python program')
        print(greeting)`

你可以通过传递不同的函数来影响产生的结果。 如果你传入bark函数，结果会像下面这样：

    `>>> greet(bark)
    'HI, I AM A PYTHON PROGRAM!'`

当然，你也可以定义一个新函数来生成不同的问候语。
比如，如果你不希望你的Python程序听起来听起来像擎天柱，下面的whisper函数可能会更好：

    `def whisper(text):
        return text.lower() + '...'
    >>> greet(whisper)
    'hi, i am a python program...'`

将函数对象作为参数传递给其他函数是很强大的功能。
它可以让你在程序中抽象并绕过其中的行为。
在这里示例中，greet函数保持不变，但你可以通过传递不同的问候行为来影响其输出。

可以接受其他函数作为参数的函数也称为高阶函数。
它们是函数式编程的必要条件。

Python中高阶函数的经典示例是内置的map函数。
其参数是一个函数对象和一个可迭代对象，然后随着迭代进行，它在每个可迭代的元素上调用函数、产生结果。

你也可以通过将bark函数进行mapping一次性格式化一系列问候语：

    `>>> list(map(bark, ['hello', 'hey', 'hi']))
    ['HELLO!', 'HEY!', 'HI!']`

如你所见，map遍历了整个列表，并将bark函数应用于每个元素。
结果，现在我们有了一个新列表。

## 函数可以嵌套

也许会令人惊讶，Python允许在函数内部定义函数。
这些通常称为嵌套函数或内部函数。这是一个例子：

    `def speak(text):
        def whisper(t):
            return t.lower() + '...'
        return whisper(text)
    >>> speak('Hello, World')
    'hello, world...'`

现在，这是怎么回事？ 每次调用speak函数时，它都会定义一个新的内部函数whisper，然后立即调用它。
我在这里理解得有点慢，但是总的来说，这仍然是相对简单的东西。

speak函数外部不存在whisper：

    `>>> whisper('Yo')
    NameError:
    "name 'whisper' is not defined"
    >>> speak.whisper
    AttributeError:
    "'function' object has no attribute 'whisper'"`

但是，如果你真的想从speak函数外访问该嵌套的whisper函数，该怎么办？
好吧，函数就是对象，你可以返回内部函数给父函数的调用者。

例如，这是一个定义了两个内部函数的函数。
根据传递给外层函数的参数，它选择并返回其中一个内部函数给调用者：

    `def get_speak_func(volume):
        def whisper(text):
            return text.lower() + '...'
    
        def yell(text):
            return text.upper() + '!'
    
        if volume > 0.5:
            return yell
        else:
            return whisper`

请注意，get_speak_func实际上并未调用其内部的任何函——它仅根据volume参数选择了适当的内部函数并将其返回：

    `>>> get_speak_func(0.3)
    <function get_speak_func.<locals>.whisper at 0x10ae18>
    >>> get_speak_func(0.7)
    <function get_speak_func.<locals>.yell at 0x1008c8>`

当然，你可以直接调用返回的函数，或者首先将其分配给变量然后再进行调用：

    `>>> speak_func = get_speak_func(0.7)
    >>> speak_func('Hello')
    'HELLO!'`

先静下心来想一想...
这意味着函数不仅可以通过参数接受行为，还可以可以返回行为。多么酷啊！

你知道吗，到这里后，事情开始有些混乱了。
我要在继续写作之前先去喝杯咖啡休息一下（我建议你也来一杯）

## 函数可以捕获局部状态

你刚刚看到了函数如何包含内部函数，并且函数还可以从父函数返回这些内部函数。

现在最好系上安全带，因为后面会有点疯狂。我们将进入更深层次的函数编程领域。（你有喝咖啡休息，对吧？）

函数不仅可以返回其他函数，而且这些内部函数也可以捕获并携带某些父函数的状态。
好吧，那是什么意思呢？

我重写一下之前的get_speak_func示例来说明这一点。
新版本带有一个“volume”和一个“text”参数，以使返回的函数可立即调用：

    `def get_speak_func(text, volume):
        def whisper():
            return text.lower() + '...'

        def yell():
            return text.upper() + '!'

        if volume > 0.5:
            return yell
        else:
            return whisper

    >>> get_speak_func('Hello, World', 0.7)()
    'HELLO, WORLD!'`

现在，仔细看看内部函数whisper和yell。
注意他们为何不再需要text参数？但是他们仍然可以访问父函数中定义的text参数。
实际上，他们似乎捕获并“记住”了这个参数的值。

执行此操作的函数称为词法闭包（简称闭包）。
即使程执行已经不在该范围内，闭包也会记住其封闭词法中的值。

实际上，这意味着函数不仅可以返回行为它们也可以预先配置这些行为。这是来说明这个想法的另一个简单例子：

    `def make_adder(n):
        def add(x):
            return x + n
        return add
    >>> plus_3 = make_adder(3)
    >>> plus_5 = make_adder(5)
    >>> plus_3(4)
    7
    >>> plus_5(4)
    9`

在此示例中，make_adder用作创建和配置“adder”函数的工厂。
注意观察adder函数仍然可以访问make_adder函数的参数n（封闭范围）。

## 对象可以表现得像函数

尽管所有函数都是Python中的对象，但反之并不成立。
对象不是函数，但是可以将它们设为可调用的，这允许你在许多情况下将它们视为函数。

如果一个对象是可调用的，则意味着你可以使用圆括号函数调用语法，甚至传递函数调用参数。
所有这些都由__call__方法实现。这是定义可调用对象的示例：

    `class Adder:
    def __init__(self, n):
        self.n = n
    def __call__(self, x):
        return self.n + x
    >>> plus_3 = Adder(3)
    >>> plus_3(4)
    7`

实际上，“调用”对象会尝试执行对象的__call__方法。

当然，并非所有对象都是可调用的。这就是为什么会有内置的用于检查对象是否看起来可调用的的callable函数：

    `>>> callable(plus_3)
    True
    >>> callable(yell)
    True
    >>> callable('hello')
    False`

## 重点

Python中包括函数在内的所有内容都是一个对象。
你可以将它们赋值给变量，将它们存储在数据结构中，将它们传递或返回给其他函数（或从其他函数返回）。
  - 一类的函数使你可以抽象和传递行为。  #　TODO: 润色 
  - 函数可以嵌套，并且可以捕获并携带一些
  - 父函数的状态。这个功能被称为闭包。
  - 可以使对象像函数一样可调用。在许多情况下，这使你可以像对待函数一样对待他们。

# 3.2 lambda是单表达式函数

Python中的lambda关键字提供了声明小型匿名函数的快捷方式。
Lambda函数的行为类似于用def关键字声明的常规函数。需要函数对象时，可以使用lambda函数。

例如，这是你定义的用于执行加法简单lambda函数：

    `>>> add = lambda x，y：x + y
    >>> add(5, 3)
    8`

你可以用def关键字声明相同的add函数，但它会更加冗长：
    
    `>>> def add(x, y):
         return x + y
    >>> add(5, 3)
    8`

现在你可能想知道，lambda有什么特别的地方？
如果它们只是用def声明函数的简明版本，有什么大不了的？

请看以下示例，在看的时候将“函数表达式”这个词记在脑海中：

    `>>> (lambda x, y: x + y)(5, 3)
    8`

好的，这是怎么回事？我只是使用lambda定义了一个add函数，然后使用参数5和3立即调用这个函数。

从概念上讲，lambda表达式lambda x, y: x + y与使用def声明的函数没有区别，它只是写在一行中。
主要区别在于在使用之前我不必分配一个名字给匿名函数对象。
我只是在lambda表达式中描述我的计算逻辑，然后像调用常规函数一样立即调用lambda表达式。

在继续之前，为了真正理解其含义，你可能需要把玩一下之前的代码。
我仍然记得我花了一段时间来理清这些东西。
所以不用担心在一个解释器的会话窗口上多花了几分钟，这是值得的。

lambda函数和常规函数之间还有另一个语法差异。
Lambda函数仅限于一个表达式。
这意味着lambda函数不能使用语句或注释——甚至没有return语句。

那么如何从lambda返回值？执行lambda函数时会计算其表达式的值，然后自动返回计算结果，因此总会有一个隐式的返回值。
这就是为什么有些人将lambda称为单个表达式函数。

## 你可以使用的lambda表达式

什么时候应该在代码中使用lambda函数？
从技术上讲，在任何你期望提供一个函数对象的时候，都可以使用lambda表达式。
而且因为lambda是匿名的，你甚至都不需要首先为其分配一个名称。

这提供了一个方便且简洁的快捷方式来定义Python中的函数。
我最常使用lambda的场景是书写简洁的key函数，用于通过提供key函数对可迭代对象进行排序：

    `>>> tuples = [(1, 'd'), (2, 'b'), (4, 'a'), (3, 'c')]
    >>> sorted(tuples, key=lambda x: x[1])
    [(4, 'a'), (2, 'b'), (3, 'c'), (1, 'd')]`

在上面的示例中，我们按第二个值对元组列表进行排序。
在这种情况下，lambda函数提供了一种快速的方法修改排序顺序。
这是你可以把玩的另一个排序示例：

    `>>> sorted(range(-5, 6), key=lambda x: x * x)
    [0, -1, 1, -2, 2, -3, 3, -4, 4, -5, 5]`

我向你展示的两个示例使用Python内置的operator.itemgetter()和abs()函数都有更简洁的实现。
但我希望你能看到使用lambda会给你带来更大的灵活性。
要按一个任意计算的key对序列进行排序？没问题，现在你知道该怎么做了。

这是关于lambda的另一件有趣的事情：就像常规的嵌套函数一样，lambda还可作为词法闭包。

什么是词法闭包？它只是一个函数的奇特名称，表示即使程序已经不再在该范围内，但是还是会记住来自封闭词法范围的值。
这是一个说明这个想法的例子：

    `>>> def make_adder(n):
         return lambda x: x + n

    >>> plus_3 = make_adder(3)
    >>> plus_5 = make_adder(5)
    >>> plus_3(4)
    7
    >>> plus_5(4)
    9`

在上面的示例中，即使n是在make_adder函数中定义的（闭包范围），x + n lambda表达式仍可以访问n的值。

有时，使用Lambda函数而不是用def关键字声明的嵌套函数可以更清楚地表达程序员的意图。
但是，老实说，这并不常见——至少这不是我所喜欢的代码风格。
所以我们再谈一点关于这个话题的信息。

##　或许你不应该

一方面，我希望本章能使你对探索Python的lambda函数感兴趣。
另一方面，我觉得是时候提出另一个警告了：应谨慎使用Lambda函数。

我知道我已经使用lambda编写了相当一部分“很酷”的代码，但实际上这对我和我的同事来说是个负担。
如果你倾向于使用lambda，花几秒钟（或几分钟）思考一下，这是否是实现这一目标的最简洁，维护型最好的方法。

例如，做下面这样的事情来节省两行代码是愚蠢的。
当然，从技术上讲，它是可行的，并且有点炫技。
但这也让下一个必须在一个很紧凑的期限内修正错误的同事感到困惑：

    `# Harmful:
    >>> class Car:
    ... rev = lambda self: print('Wroom!')
    ... crash = lambda self: print('Boom!')
    >>> my_car = Car()
    >>> my_car.crash()
    'Boom!'`

我对使用lambda的复杂map()或filter()函数有类似的感觉。
通常，使用列表表达式或生成器表达式会更简洁：

    `# Harmful:
    >>> list(filter(lambda x: x % 2 == 0, range(16)))
    [0, 2, 4, 6, 8, 10, 12, 14]
    # Better:
    >>> [x for x in range(16) if x % 2 == 0]
    [0, 2, 4, 6, 8, 10, 12, 14]`

