## 4.1 对象比较，is还是==

小时候，我们的邻居有两只双胞胎猫。
它们看起来似乎完全相同——相同的木炭皮毛和相同的绿色瞳孔。
除了一些古怪个性，你无法通过观察它们将它们分开。
当然，虽然它们看起来完全一样，但是它们是两只不同的猫。

这使我想到了相等与相同之间的意义差异。
而这种差异对于理解Python的is和==比较运算符的行为至关重要。

==运算符通过检查是否相等来进行比较：如果这些猫是
Python对象，将它们与==运算符进行比较，我们将得到
“两只猫相等”的结论。

但是，is运算符会比较特性：如果我们使用is运算符，我们会得到“这是两只猫不通”的结论。

但是，在我陷入这个问题之前，让我们看一些真实的例子。
首先，我们创建一个新的列表对象并将其命名为a，然后定义另一个变量b，将其指向同一列表对象：
    
    `>>> a = [1, 2, 3]
    >>> b = a`

让我们检查一下这两个变量。
我们可以看到他们指向看起来相同的列表：

由于两个列表对象看起来相同，因此当我们使用==运算符比较它们时，我们可以得到预期的结果：

    `>>> a == b
    True`


但是，这并不能告诉我们a和b是否实际上指向相同的对象。
当然，我们知道它们是，因为我们早些时候为它们进行了赋值，但假设我们不知道，我们怎么确定呢？

答案是使用is运算符比较两个变量。这可以确认两个变量实际上都指向一个列表对象：

    `>>> a is b
    True`

让我们看看当我们创建列表的副本时会发生什么。我们可以通过在现有列表上调用list()来创建副本，我们将其命名为c：

    `>>> c = list(a)`
    
同样，你会看到我们刚刚创建的新列表看起来与和a和b指向的列表是相同的：

    `>>> c [1, 2, 3]`
    
现在，事情开始变得有趣了。让我们使用==运算符对初始列表和其副本c进行比较。
你期望得到什么答案？

    `>>> a == c
     True`
     
好的，我希望这就是你期望的结果。这个结果告诉我们列表c和a具有相同的内容。
在Python中它们被认为是相等的。
但是它们实际上是指向同一个对象吗？让我们使用is运算符看看：

    `>>> a is c
     False`
     
Boom！这里我们得到了不同的结果。
c和a指向两个不同的对象，即使它们内容可能相同。

回顾一下，让我们尝试用两个简短的定义区分is和==：
    - 如果两个变量指向相同的对象，is表达式结果为True。
    - 如果变量引用的对象相等，==表达式的结果为True。
    
你需要决定使用is和==之前，想一想双胞胎猫（狗也行）。

## 4.2 字符串转换（每个类都需要一个__repr__方法）

当你在Python中定义自己的类，
然后尝试打印它的一个实例到控制台时（或在解释器会话中检查它），
你得到不那么令人满意的结果。
默认的字符串转换行为是很基础的，并且缺乏细节：

    `class Car:
     def __init__(self, color, mileage):
         self.color = color
         self.mileage = mileage
     >>> my_car = Car('red', 37281)
     >>> print(my_car)
     <__console__.Car object at 0x109b73da0>
     >>> my_car
     <__console__.Car object at 0x109b73da0>`

默认情况下，你得到的只是一个包含类名称和ID的字符串（这是CPython中对象的内存地址。）
有总比没有好，但是它也不是很有用。

你可能会发现自己尝试通过直接打印类的属性，
甚至通过在类中添加自定义to_string（）来解决此问题。

    `>>> print(my_car.color, my_car.mileage)
     red 37281`







