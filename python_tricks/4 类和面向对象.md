## 4.1 对象比较，is还是==

小时候，我们的邻居有两只双胞胎猫。
它们看起来似乎完全相同——相同的木炭皮毛和相同的绿色瞳孔。
除了一些古怪个性，你无法通过观察它们将它们分开。
当然，虽然它们看起来完全一样，但是它们是两只不同的猫。

这使我想到了相等与相同之间的意义差异。
而这种差异对于理解Python的is和==比较运算符的行为至关重要。

==运算符通过检查是否相等来进行比较：如果这些猫是
Python对象，将它们与==运算符进行比较，我们将得到
“两只猫相等”的结论。

但是，is运算符会比较特性：如果我们使用is运算符，我们会得到“这是两只猫不通”的结论。

但是，在我陷入这个问题之前，让我们看一些真实的例子。
首先，我们创建一个新的列表对象并将其命名为a，然后定义另一个变量b，将其指向同一列表对象：
    
    `>>> a = [1, 2, 3]
    >>> b = a`

让我们检查一下这两个变量。
我们可以看到他们指向看起来相同的列表：

由于两个列表对象看起来相同，因此当我们使用==运算符比较它们时，我们可以得到预期的结果：

    `>>> a == b
    True`


但是，这并不能告诉我们a和b是否实际上指向相同的对象。
当然，我们知道它们是，因为我们早些时候为它们进行了赋值，但假设我们不知道，我们怎么确定呢？

答案是使用is运算符比较两个变量。这可以确认两个变量实际上都指向一个列表对象：

    `>>> a is b
    True`

让我们看看当我们创建列表的副本时会发生什么。我们可以通过在现有列表上调用list()来创建副本，我们将其命名为c：

    `>>> c = list(a)`
    
同样，你会看到我们刚刚创建的新列表看起来与和a和b指向的列表是相同的：

    `>>> c [1, 2, 3]`
    
现在，事情开始变得有趣了。让我们使用==运算符对初始列表和其副本c进行比较。
你期望得到什么答案？

    `>>> a == c
     True`
     
好的，我希望这就是你期望的结果。这个结果告诉我们列表c和a具有相同的内容。
在Python中它们被认为是相等的。
但是它们实际上是指向同一个对象吗？让我们使用is运算符看看：

    `>>> a is c
     False`
     
Boom！这里我们得到了不同的结果。
c和a指向两个不同的对象，即使它们内容可能相同。

回顾一下，让我们尝试用两个简短的定义区分is和==：
    - 如果两个变量指向相同的对象，is表达式结果为True。
    - 如果变量引用的对象相等，==表达式的结果为True。
    
你需要决定使用is和==之前，想一想双胞胎猫（狗也行）。

## 4.2 字符串转换（每个类都需要一个__repr__方法）

当你在Python中定义自己的类，
然后尝试打印它的一个实例到控制台时（或在解释器会话中检查它），
你得到不那么令人满意的结果。
默认的字符串转换行为是很基础的，并且缺乏细节：

    `class Car:
     def __init__(self, color, mileage):
         self.color = color
         self.mileage = mileage
     >>> my_car = Car('red', 37281)
     >>> print(my_car)
     <__console__.Car object at 0x109b73da0>
     >>> my_car
     <__console__.Car object at 0x109b73da0>`

默认情况下，你得到的只是一个包含类名称和ID的字符串（这是CPython中对象的内存地址。）
有总比没有好，但是它也不是很有用。

你可能会尝试直接打印类的属性，甚至通过在类中添加自定义to_string()来解决此问题。

    `>>> print(my_car.color, my_car.mileage)
     red 37281`

这里大致的想法是正确的，但它忽略了Python将对象表示为字符串的约定和内置机制。

你无需构建自己的字符串转换机制，最好是在类中添加__str__和__repr__方法。
它们是控制在不同情况下将对象转换为字符串的方法，这种方式更加符合python的风格。
让我们看一下这些方法在实际中的应用。我们先在类Car的定义中添加__str__方法作为开始：

    `class Car:
        def __init__(self, color, mileage):
            self.color = color
            self.mileage = mileage

        def __str__(self):
            return f'a {self.color} car'`

现在，当你尝试打印或检查Car的实例时，将会看到一个和之前不同，略有改善的结果：

    `>>> my_car = Car('red', 37281)
    >>> print(my_car)
    'a red car'
    >>> my_car
    <__console__.Car object at 0x109ca24e0>
    `

在控制台中检查Car对象仍会输出包含对象ID的结果，这和之前没有区别。
但是打印对象会得到我们添加的__str__方法返回的字符串。

__str__是Python的双下划线方法之一，并在你尝试通过将对象转换为字符串方法时被调用：

    `>>> print(my_car)
    a red car

    >>> str(my_car)
    'a red car'
    >>> '{}'.format(my_car)
    'a red car'

有了正确的__str__实现后，你就不必再关心直接打印对象属性或编写单独的to_string()函数。
这是符合Python风格的控制字符串转换的方式。

顺便说一句，有些人将Python的双下划线方法称为“魔术方法”。
但是这些方法一点也不魔幻。
这些方法以双下划线开始和结束只是Python将其标记为核心特性的命名约定。
它还有助于避免与你自己的方法和属性产生命名冲突。
对象初始化函数__init__遵循同样的约定，没有什么神奇或神秘的东西。

不要害怕使用Python的双下划线方法——它们实际上是为了帮助你。

### __str__ vs __repr__

现在，我们关于的字符串转换的故事还没有结束。
你看到了吗？在解释器中检查my_car对象时，仍然输出了奇怪的<Car object at 0x109ca24e0>？

发生这种情况是因为在Python 3中实际上有两种下划线方法在控制如何将对象转换为字符串。
第一个是你刚刚了解的__str__。
第二个是__repr__，它的工作方式类似于__str__，
但是它用在不同的场景。（Python 2.x还有一个__unicode__方法，我会在稍后介绍）。

这是一个简单的例子，你可以用来了解什么时候使用__str__，什么时候使用__repr__。
让我们重新定义我们的Car类，以便它包含__str__和__repr__方法，同时又具有易于区分的输出：

    `class Car:
        def __init__(self, color, mileage):
            self.color = color
            self.mileage = mileage

        def __repr__(self):
            return '__repr__ for Car'

        def __str__(self):
            return '__str__ for Car'`

现在，当你浏览前面的示例时，你可以看到在每种情况下那种方法在控制字符串的转换：

    `>>> my_car = Car('red', 37281)
    >>> print(my_car)
    __str__ for Car
    >>> '{}'.format(my_car)
    '__str__ for Car'
    >>> my_car
    __repr__ for Car`


此实验证实，在Python解释器会话中检查对象只是会打印对象的__repr__结果。
有趣的是，诸如列表和字典之类的容器始终使用__repr__代表它们包含的对象。
即使你在容器本身上调用__str__方法：

    `str([my_car])
    '[__repr__ for Car]'`

要在这两种字符串转换方法之间进行选择以更清楚地表达代码的意图时，最好使用内置的str()和repr()函数。
与直接调用对象的__str__或__repr__属性相比，使用它们更可取，因为它更好看，并且输出相同的结果：

    `>>> str(my_car)
    '__str__ for Car'
    >>> repr(my_car)
    '__repr__ for Car'`

即使这项研究结束了，你可能仍想知道__str__和__repr__之间的差异是什么？
他们两个似乎都达到了相同的目的，因此什么时候使用那个还不是很清楚。

遇到诸如此类的问题，通常最好先查看一下Python标准库的做法。
是时候设计另一个实验了。
我们将创建一个datetime.date对象，观察它怎么使用__repr__和__str__来控制字符串转换：

    `>>> import datetime
    >>> today = datetime.date.today()`

日期对象的__str__函数的结果首先要是可读的。
这意味着要返回简洁明了的文字形式以供人阅读——以你觉得很舒服的方式显示给用户。

因此，当我们在日期对象上调用str（）时，得到的东西看起来像是ISO日期格式：

    `>>> str(today)
    '2017-02-02'`

使用__repr__最重要的理念是其结果应该是明确的。
产生的字符串更多地被开发人员用作调试的辅助工具。
为此，它需要尽可能明确表述这个对象是什么。
这就是为什么你在对象上调用repr()会得到更详尽结果的原因。
它甚至包括完整的模块和类名称：

    `>>> repr(today)
    'datetime.date(2017, 2, 2)'`

我们可以复制并粘贴__repr__返回的字符串并将其作为有效的Python代码执行来重新创建原始的date对象。
这是编写自己的repr方法时要牢记的一个目标。

另一方面，我发现这很难付诸实践。
通常情况下，这样做是不值得的，它只会成为你额外的负担。
我的经验是使__repr__字符串清晰无误并且对开发人员有帮助，但我不希望他们能够还原对象的完整状态。






